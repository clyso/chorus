# Chorus Helm Chart Values
# See README.md for documentation

# =============================================================================
# GLOBAL SETTINGS
# =============================================================================
global:
  # Node selector applied to all components
  nodeSelector: {}
  # Tolerations applied to all components
  tolerations: []
  # Affinity rules applied to all components
  affinity: {}

nameOverride: ""
fullnameOverride: ""

imagePullSecrets: []

serviceAccount:
  create: true
  annotations: {}
  name: ""

# =============================================================================
# DYNAMIC CREDENTIALS
# =============================================================================
# Manage storage credentials via API instead of config files
# When enabled, credentials can be added/updated via chorctl set-user command
dynamicCredentials:
  enabled: false
  disableEncryption: false
  pollInterval: 3s

  # Master password for encrypting credentials in Redis
  # Option 1: Inline password (for dev/testing only)
  masterPassword: ""

  # Option 2: Use existing secret (recommended for production)
  # Secret should contain the master password
  existingSecret: ""
  existingSecretKey: "master-password"

# =============================================================================
# STORAGE CONFIGURATION
# =============================================================================
# Storage definitions (non-secret parts go to ConfigMap)
# Credentials are specified separately in 'credentials' section below
storage:
  # Name of the main storage (must match a key in storages below)
  main: ""

  # Storage definitions
  # For S3: same config works for both proxy and worker
  # For Swift: worker uses authURL (Keystone), proxy uses storageURL
  storages: {}
    # Example S3 storage:
    # main:
    #   type: S3
    #   address: s3.example.com
    #   provider: Ceph  # Ceph, Minio, or Other
    #   isSecure: true
    #   defaultRegion: "us-east-1"
    #   healthCheckInterval: 10s
    #   httpTimeout: 1m
    #   rateLimit:
    #     enabled: false
    #     rpm: 60
    #
    # Example Swift storage:
    # swift-main:
    #   type: SWIFT
    #   # Worker config - uses Keystone for authentication
    #   authURL: http://keystone:5000/v3
    #   storageEndpointName: swift
    #   storageEndpointType: object-store
    #   region: RegionOne
    #   # Proxy config - direct Swift endpoint (proxy cannot use Keystone)
    #   storageURL: http://swift:8080/v1

# =============================================================================
# CREDENTIALS (Secret)
# =============================================================================
# Storage credentials - stored in Kubernetes Secret
credentials:
  # Per-storage credentials
  storages: {}
    # S3 credentials example:
    # main:
    #   user1:
    #     accessKeyID: "AKIAIOSFODNN7EXAMPLE"
    #     secretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    #
    # Swift credentials example (key must be OpenStack project ID):
    # swift-main:
    #   b6ebf758c9894224a105e5531eaa4ce9:
    #     username: admin
    #     password: secret
    #     domainName: Default
    #     tenantName: admin

# Use existing secret instead of creating one
# Secret must have 'config' key with YAML content matching override.yaml format
existingCredentialsSecret: ""

# =============================================================================
# FEATURES
# =============================================================================
features:
  tagging: true
  acl: true

# =============================================================================
# REDIS CONFIGURATION
# =============================================================================
# Bundled Redis (Bitnami chart)
# When redis.enabled=true, a password is auto-generated and stored in a secret
# The Chorus components use this secret for Redis authentication
redis:
  enabled: true
  architecture: standalone
  auth:
    enabled: true
    # Leave empty to auto-generate password, or specify existing secret name
    existingSecret: ""
    existingSecretPasswordKey: redis-password
  # Persistence (recommended for production):
  # master:
  #   persistence:
  #     enabled: true
  #     size: 64Gi

# External Redis (when redis.enabled=false)
externalRedis:
  # Single instance or sentinel addresses
  addresses: []
    # - redis.example.com:6379
  user: ""
  password: ""
  # Or use existing secret
  existingSecret: ""
  existingSecretPasswordKey: "password"
  # Sentinel configuration
  sentinel:
    masterName: ""
    user: ""
    password: ""
  # TLS
  tls:
    enabled: false
    insecure: false

# =============================================================================
# PROXY
# =============================================================================
proxy:
  enabled: true

  replicas: 2

  image:
    repository: harbor.clyso.com/chorus/proxy
    tag: "" # Defaults to Chart.appVersion
    pullPolicy: Always

  # Resource limits
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  # Pod-level settings
  podAnnotations: {}
  podSecurityContext: {}
  securityContext:
    allowPrivilegeEscalation: false

  # Scheduling
  nodeSelector: {}
  tolerations: []
  affinity: {}

  # Pod Disruption Budget
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
    # maxUnavailable: 1

  # Service configuration
  service:
    type: ClusterIP
    port: 9669
    annotations: {}

  # Proxy-specific config
  config:
    port: 9669
    address: "" # External address (for CORS, etc.)

    log:
      json: true
      level: info

    metrics:
      enabled: false

    trace:
      enabled: false
      endpoint: ""

    cors:
      enabled: false
      allowAll: false
      whitelist: []

    auth:
      allowV2Signature: false
      useStorage: "" # Use credentials from this storage
      custom: {} # Or define custom credentials
        # user1:
        #   accessKeyID: xxx
        #   secretAccessKey: xxx

# =============================================================================
# WORKER
# =============================================================================
worker:
  replicas: 2

  image:
    repository: harbor.clyso.com/chorus/worker
    tag: "" # Defaults to Chart.appVersion
    pullPolicy: Always

  resources: {}

  podAnnotations: {}
  podSecurityContext: {}
  securityContext:
    allowPrivilegeEscalation: false

  nodeSelector: {}
  tolerations: []
  affinity: {}

  podDisruptionBudget:
    enabled: false
    minAvailable: 1

  # gRPC API service (for chorctl)
  grpcService:
    type: ClusterIP
    port: 9670
    annotations: {}

  # REST API service
  restService:
    type: ClusterIP
    port: 9671
    annotations: {}

  # Webhook service (only created when webhook uses separate ports)
  webhookService:
    type: ClusterIP
    annotations: {}

  config:
    concurrency: 10

    api:
      enabled: true
      grpcPort: 9670
      httpPort: 9671

      webhook:
        # Enable webhook endpoints for S3 notifications and Swift events.
        # Webhook is handled by the worker â€” no separate service needed.
        enabled: false
        # Externally reachable base URL for webhook endpoints.
        # If empty and webhook is enabled, auto-filled with internal k8s service URL:
        #   http://<fullname>-rest.<namespace>.svc.cluster.local:<restPort>
        # Override when the storage pushes from outside the cluster (e.g. via ingress).
        baseUrl: ""
        # Run webhook on separate ports (both must be set, or both 0).
        # When 0, webhook shares the main API ports above.
        grpcPort: 0
        httpPort: 0

    log:
      json: true
      level: info

    metrics:
      enabled: false

    trace:
      enabled: false
      endpoint: ""

# =============================================================================
# WEB UI
# =============================================================================
ui:
  enabled: false

  replicas: 1

  image:
    repository: harbor.clyso.com/chorus/web-ui
    tag: ""
    pullPolicy: Always

  resources:
    limits:
      cpu: 50m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 128Mi

  podAnnotations: {}
  podSecurityContext: {}
  securityContext:
    allowPrivilegeEscalation: false

  nodeSelector: {}
  tolerations: []
  affinity: {}

  service:
    type: ClusterIP
    port: 9672
    annotations: {}

# =============================================================================
# INGRESS
# =============================================================================
ingress:
  # Ingress for S3 Proxy
  proxy:
    enabled: false
    className: ""
    annotations: {}
      # nginx.ingress.kubernetes.io/proxy-body-size: "0"
      # nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    hosts: []
      # - host: s3.example.com
      #   paths:
      #     - path: /
      #       pathType: Prefix
    tls: []
      # - secretName: s3-tls
      #   hosts:
      #     - s3.example.com

  # Ingress for Worker REST API
  api:
    enabled: false
    className: ""
    annotations: {}
    hosts: []
      # - host: chorus-api.example.com
      #   paths:
      #     - path: /
      #       pathType: Prefix
    tls: []

  # Ingress for webhook endpoints (S3 notifications, Swift events).
  # Useful when the source storage is outside the cluster.
  webhook:
    enabled: false
    className: ""
    annotations: {}
      # nginx.ingress.kubernetes.io/proxy-body-size: "0"
    # Route to webhook gRPC port instead of HTTP.
    # Adds nginx.ingress.kubernetes.io/backend-protocol: GRPC automatically.
    grpc: false
    hosts: []
      # - host: chorus-webhook.example.com
      #   paths:
      #     - path: /
      #       pathType: Prefix
    tls: []

  # Ingress for Web UI
  ui:
    enabled: false
    className: ""
    annotations: {}
    hosts: []
      # - host: chorus.example.com
      #   paths:
      #     - path: /
      #       pathType: Prefix
    tls: []
