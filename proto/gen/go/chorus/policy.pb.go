// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: chorus/policy.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ReplicationSwitch_Status int32

const (
	// Switch is not started yet
	ReplicationSwitch_NOT_STARTED ReplicationSwitch_Status = 0
	// Switch is in progress. Draining replication events queue.
	// For switch with downtime, requests to target are blocked at this point.
	ReplicationSwitch_IN_PROGRESS ReplicationSwitch_Status = 1
	// Switch is in progress. Queue is drained. Checking if source and
	// destination targets are the same. Requests are still blocked. Used only
	// for switch with downtime with enabled bucket check.
	ReplicationSwitch_CHECK_IN_PROGRESS ReplicationSwitch_Status = 2
	// Switch failed to complete in downtime window and was aborted.
	// Requests to target are unblocked. Used only for switch with downtime.
	// If cron downtime_window is used, switch will be retried on next cron
	// execution.
	ReplicationSwitch_ERROR ReplicationSwitch_Status = 3
	// Switch was not able to start in given downtime window because conditions
	// were not met. Used only for switch with downtime. If cron downtime_window
	// is used, switch will be retried on next cron execution.
	ReplicationSwitch_SKIPPED ReplicationSwitch_Status = 4
	// Switch was successfully completed.
	// All data was replicated to replication destination target and all read
	// and all requests are now routed to it.
	ReplicationSwitch_DONE ReplicationSwitch_Status = 5
)

// Enum value maps for ReplicationSwitch_Status.
var (
	ReplicationSwitch_Status_name = map[int32]string{
		0: "NOT_STARTED",
		1: "IN_PROGRESS",
		2: "CHECK_IN_PROGRESS",
		3: "ERROR",
		4: "SKIPPED",
		5: "DONE",
	}
	ReplicationSwitch_Status_value = map[string]int32{
		"NOT_STARTED":       0,
		"IN_PROGRESS":       1,
		"CHECK_IN_PROGRESS": 2,
		"ERROR":             3,
		"SKIPPED":           4,
		"DONE":              5,
	}
)

func (x ReplicationSwitch_Status) Enum() *ReplicationSwitch_Status {
	p := new(ReplicationSwitch_Status)
	*p = x
	return p
}

func (x ReplicationSwitch_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReplicationSwitch_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_chorus_policy_proto_enumTypes[0].Descriptor()
}

func (ReplicationSwitch_Status) Type() protoreflect.EnumType {
	return &file_chorus_policy_proto_enumTypes[0]
}

func (x ReplicationSwitch_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReplicationSwitch_Status.Descriptor instead.
func (ReplicationSwitch_Status) EnumDescriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{13, 0}
}

// Represents user-level and bucket-level replication source and destination
// targets.
// - User-level replicates all existing and future buckets of the user.
// - Bucket-level  replicates a single bucket.
type ReplicationID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// REQUIRED: Replication user from chorus storage credential config.
	// Selected user must be configured for both from/to storages.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// REQUIRED: source storage name from chorus storage config.
	FromStorage string `protobuf:"bytes,2,opt,name=from_storage,json=fromStorage,proto3" json:"from_storage,omitempty"`
	// REQUIRED: destination storage name from chorus storage config.
	// Can be equal to from_storage if both from/to buckets are set and different.
	ToStorage string `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3" json:"to_storage,omitempty"`
	// OPTIONAL: source bucket name.
	// For user-level replication, this field must be empty.
	// For bucket-level replication, this field must be set.
	FromBucket *string `protobuf:"bytes,4,opt,name=from_bucket,json=fromBucket,proto3,oneof" json:"from_bucket,omitempty"`
	// OPTIONAL: destination bucket name.
	// For user-level replication, this field must be empty.
	// For bucket-level replication, this field must be set. From/to buckets can
	// be different.
	ToBucket      *string `protobuf:"bytes,5,opt,name=to_bucket,json=toBucket,proto3,oneof" json:"to_bucket,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationID) Reset() {
	*x = ReplicationID{}
	mi := &file_chorus_policy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationID) ProtoMessage() {}

func (x *ReplicationID) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationID.ProtoReflect.Descriptor instead.
func (*ReplicationID) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{0}
}

func (x *ReplicationID) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *ReplicationID) GetFromStorage() string {
	if x != nil {
		return x.FromStorage
	}
	return ""
}

func (x *ReplicationID) GetToStorage() string {
	if x != nil {
		return x.ToStorage
	}
	return ""
}

func (x *ReplicationID) GetFromBucket() string {
	if x != nil && x.FromBucket != nil {
		return *x.FromBucket
	}
	return ""
}

func (x *ReplicationID) GetToBucket() string {
	if x != nil && x.ToBucket != nil {
		return *x.ToBucket
	}
	return ""
}

// Configures new user-level or bucket-level replication.
type AddReplicationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// REQUIRED: Specifies replication source and destination.
	Id *ReplicationID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// OPTIONAL: Additional replication options.
	Opts          *ReplicationOpts `protobuf:"bytes,2,opt,name=opts,proto3" json:"opts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddReplicationRequest) Reset() {
	*x = AddReplicationRequest{}
	mi := &file_chorus_policy_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddReplicationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddReplicationRequest) ProtoMessage() {}

func (x *AddReplicationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddReplicationRequest.ProtoReflect.Descriptor instead.
func (*AddReplicationRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{1}
}

func (x *AddReplicationRequest) GetId() *ReplicationID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *AddReplicationRequest) GetOpts() *ReplicationOpts {
	if x != nil {
		return x.Opts
	}
	return nil
}

// Additional replication options for bucket and user-level replications.
type ReplicationOpts struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Webhook URL of chorus agent. Can be configured only for bucket-level.
	// Required if chorus agent setup is used to capture ongoing storage events.
	AgentUrl      *string `protobuf:"bytes,1,opt,name=agent_url,json=agentUrl,proto3,oneof" json:"agent_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationOpts) Reset() {
	*x = ReplicationOpts{}
	mi := &file_chorus_policy_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationOpts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationOpts) ProtoMessage() {}

func (x *ReplicationOpts) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationOpts.ProtoReflect.Descriptor instead.
func (*ReplicationOpts) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{2}
}

func (x *ReplicationOpts) GetAgentUrl() string {
	if x != nil && x.AgentUrl != nil {
		return *x.AgentUrl
	}
	return ""
}

// Filters replications list.
type ListReplicationsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// if true, user-level replications will be excluded from response.
	HideUserReplications bool `protobuf:"varint,1,opt,name=hide_user_replications,json=hideUserReplications,proto3" json:"hide_user_replications,omitempty"`
	// if true, bucket-level replications will be excluded from response.
	HideBucketReplications bool `protobuf:"varint,2,opt,name=hide_bucket_replications,json=hideBucketReplications,proto3" json:"hide_bucket_replications,omitempty"`
	// if true, replications will be listed without switch info.
	HideSwitchInfo bool `protobuf:"varint,3,opt,name=hide_switch_info,json=hideSwitchInfo,proto3" json:"hide_switch_info,omitempty"`
	// OPTIONAL: filter to apply to replications list.
	Filter        *ListReplicationsRequest_Filter `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListReplicationsRequest) Reset() {
	*x = ListReplicationsRequest{}
	mi := &file_chorus_policy_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListReplicationsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListReplicationsRequest) ProtoMessage() {}

func (x *ListReplicationsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListReplicationsRequest.ProtoReflect.Descriptor instead.
func (*ListReplicationsRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{3}
}

func (x *ListReplicationsRequest) GetHideUserReplications() bool {
	if x != nil {
		return x.HideUserReplications
	}
	return false
}

func (x *ListReplicationsRequest) GetHideBucketReplications() bool {
	if x != nil {
		return x.HideBucketReplications
	}
	return false
}

func (x *ListReplicationsRequest) GetHideSwitchInfo() bool {
	if x != nil {
		return x.HideSwitchInfo
	}
	return false
}

func (x *ListReplicationsRequest) GetFilter() *ListReplicationsRequest_Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

type ListReplicationsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Replications  []*Replication         `protobuf:"bytes,1,rep,name=replications,proto3" json:"replications,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListReplicationsResponse) Reset() {
	*x = ListReplicationsResponse{}
	mi := &file_chorus_policy_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListReplicationsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListReplicationsResponse) ProtoMessage() {}

func (x *ListReplicationsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListReplicationsResponse.ProtoReflect.Descriptor instead.
func (*ListReplicationsResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{4}
}

func (x *ListReplicationsResponse) GetReplications() []*Replication {
	if x != nil {
		return x.Replications
	}
	return nil
}

// Represents specification and status of user-level or bucket-level
// replication.
type Replication struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies replication source and destination.
	Id *ReplicationID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Additional replication options.
	Opts *ReplicationOpts `protobuf:"bytes,2,opt,name=opts,proto3" json:"opts,omitempty"`
	// Replication creation time
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// true if replication is paused
	IsPaused bool `protobuf:"varint,4,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// true if initial replication phase is done.
	// Initial phase copies all data existing in source at the moment of
	// replication creation.
	IsInitDone bool `protobuf:"varint,5,opt,name=is_init_done,json=isInitDone,proto3" json:"is_init_done,omitempty"`
	// Approximate number of objects listed during initial replication.
	// Corresponds to total number of tasks created for initial replication queue.
	InitObjListed int64 `protobuf:"varint,6,opt,name=init_obj_listed,json=initObjListed,proto3" json:"init_obj_listed,omitempty"`
	// Approximate number of objects processed during initial replication.
	// Corresponds to total number of tasks completed from initial replication
	// queue.
	InitObjDone int64 `protobuf:"varint,7,opt,name=init_obj_done,json=initObjDone,proto3" json:"init_obj_done,omitempty"`
	// Number of source data change events captured and queued for replication.
	// Corresponds to total number of tasks created for event replication queue.
	Events int64 `protobuf:"varint,8,opt,name=events,proto3" json:"events,omitempty"`
	// Number of source data change events synced to destination.
	// Corresponds to total number of tasks completed from event replication
	// queue.
	EventsDone int64 `protobuf:"varint,9,opt,name=events_done,json=eventsDone,proto3" json:"events_done,omitempty"`
	// Approximate time lag for syncing events to destination.
	// Corresponds to age of the oldest unprocessed task in event replication
	// queue (aka replication queue latency).
	EventLag  *durationpb.Duration `protobuf:"bytes,10,opt,name=event_lag,json=eventLag,proto3" json:"event_lag,omitempty"`
	HasSwitch bool                 `protobuf:"varint,11,opt,name=has_switch,json=hasSwitch,proto3" json:"has_switch,omitempty"`
	// true if replication is archived. Archived replication will not generate or
	// sync new events. The main purpose of archived replication is to keep
	// replication metadata for future reference. Archived replication can be
	// safely deleted.
	IsArchived bool                   `protobuf:"varint,12,opt,name=is_archived,json=isArchived,proto3" json:"is_archived,omitempty"`
	ArchivedAt *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=archived_at,json=archivedAt,proto3" json:"archived_at,omitempty"`
	// If replication has associated switch, contains its status info.
	SwitchInfo    *ReplicationSwitch `protobuf:"bytes,14,opt,name=switch_info,json=switchInfo,proto3,oneof" json:"switch_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Replication) Reset() {
	*x = Replication{}
	mi := &file_chorus_policy_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Replication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Replication) ProtoMessage() {}

func (x *Replication) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Replication.ProtoReflect.Descriptor instead.
func (*Replication) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{5}
}

func (x *Replication) GetId() *ReplicationID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Replication) GetOpts() *ReplicationOpts {
	if x != nil {
		return x.Opts
	}
	return nil
}

func (x *Replication) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Replication) GetIsPaused() bool {
	if x != nil {
		return x.IsPaused
	}
	return false
}

func (x *Replication) GetIsInitDone() bool {
	if x != nil {
		return x.IsInitDone
	}
	return false
}

func (x *Replication) GetInitObjListed() int64 {
	if x != nil {
		return x.InitObjListed
	}
	return 0
}

func (x *Replication) GetInitObjDone() int64 {
	if x != nil {
		return x.InitObjDone
	}
	return 0
}

func (x *Replication) GetEvents() int64 {
	if x != nil {
		return x.Events
	}
	return 0
}

func (x *Replication) GetEventsDone() int64 {
	if x != nil {
		return x.EventsDone
	}
	return 0
}

func (x *Replication) GetEventLag() *durationpb.Duration {
	if x != nil {
		return x.EventLag
	}
	return nil
}

func (x *Replication) GetHasSwitch() bool {
	if x != nil {
		return x.HasSwitch
	}
	return false
}

func (x *Replication) GetIsArchived() bool {
	if x != nil {
		return x.IsArchived
	}
	return false
}

func (x *Replication) GetArchivedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ArchivedAt
	}
	return nil
}

func (x *Replication) GetSwitchInfo() *ReplicationSwitch {
	if x != nil {
		return x.SwitchInfo
	}
	return nil
}

// Request list of bucket available for replication for given user and from/to
// storages.
type AvailableBucketsRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	User           string                 `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	FromStorage    string                 `protobuf:"bytes,2,opt,name=from_storage,json=fromStorage,proto3" json:"from_storage,omitempty"`
	ToStorage      string                 `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3" json:"to_storage,omitempty"`
	ShowReplicated bool                   `protobuf:"varint,4,opt,name=show_replicated,json=showReplicated,proto3" json:"show_replicated,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AvailableBucketsRequest) Reset() {
	*x = AvailableBucketsRequest{}
	mi := &file_chorus_policy_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailableBucketsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailableBucketsRequest) ProtoMessage() {}

func (x *AvailableBucketsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailableBucketsRequest.ProtoReflect.Descriptor instead.
func (*AvailableBucketsRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{6}
}

func (x *AvailableBucketsRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *AvailableBucketsRequest) GetFromStorage() string {
	if x != nil {
		return x.FromStorage
	}
	return ""
}

func (x *AvailableBucketsRequest) GetToStorage() string {
	if x != nil {
		return x.ToStorage
	}
	return ""
}

func (x *AvailableBucketsRequest) GetShowReplicated() bool {
	if x != nil {
		return x.ShowReplicated
	}
	return false
}

type AvailableBucketsResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Buckets           []string               `protobuf:"bytes,1,rep,name=buckets,proto3" json:"buckets,omitempty"`
	ReplicatedBuckets []string               `protobuf:"bytes,2,rep,name=replicated_buckets,json=replicatedBuckets,proto3" json:"replicated_buckets,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AvailableBucketsResponse) Reset() {
	*x = AvailableBucketsResponse{}
	mi := &file_chorus_policy_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailableBucketsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailableBucketsResponse) ProtoMessage() {}

func (x *AvailableBucketsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailableBucketsResponse.ProtoReflect.Descriptor instead.
func (*AvailableBucketsResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{7}
}

func (x *AvailableBucketsResponse) GetBuckets() []string {
	if x != nil {
		return x.Buckets
	}
	return nil
}

func (x *AvailableBucketsResponse) GetReplicatedBuckets() []string {
	if x != nil {
		return x.ReplicatedBuckets
	}
	return nil
}

type CompareBucketRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Represents source and destination bucket to compare.
	Target *ReplicationID `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// set true to get list of matching files (match) in response
	ShowMatch     bool `protobuf:"varint,2,opt,name=show_match,json=showMatch,proto3" json:"show_match,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompareBucketRequest) Reset() {
	*x = CompareBucketRequest{}
	mi := &file_chorus_policy_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompareBucketRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompareBucketRequest) ProtoMessage() {}

func (x *CompareBucketRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompareBucketRequest.ProtoReflect.Descriptor instead.
func (*CompareBucketRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{8}
}

func (x *CompareBucketRequest) GetTarget() *ReplicationID {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *CompareBucketRequest) GetShowMatch() bool {
	if x != nil {
		return x.ShowMatch
	}
	return false
}

type CompareBucketResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// true if storage's buckets have the same content
	IsMatch bool `protobuf:"varint,1,opt,name=is_match,json=isMatch,proto3" json:"is_match,omitempty"`
	// list of missing files in 'from storage' bucket
	MissFrom []string `protobuf:"bytes,2,rep,name=miss_from,json=missFrom,proto3" json:"miss_from,omitempty"`
	// list of missing files in 'to storage' bucket
	MissTo []string `protobuf:"bytes,3,rep,name=miss_to,json=missTo,proto3" json:"miss_to,omitempty"`
	// list of files with different content
	Differ []string `protobuf:"bytes,4,rep,name=differ,proto3" json:"differ,omitempty"`
	// list of errors occurred during comparison
	Error []string `protobuf:"bytes,5,rep,name=error,proto3" json:"error,omitempty"`
	// list matched files in storages bucket.
	// will be empty if request parameter show_match set to false.
	Match         []string `protobuf:"bytes,6,rep,name=match,proto3" json:"match,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompareBucketResponse) Reset() {
	*x = CompareBucketResponse{}
	mi := &file_chorus_policy_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompareBucketResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompareBucketResponse) ProtoMessage() {}

func (x *CompareBucketResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompareBucketResponse.ProtoReflect.Descriptor instead.
func (*CompareBucketResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{9}
}

func (x *CompareBucketResponse) GetIsMatch() bool {
	if x != nil {
		return x.IsMatch
	}
	return false
}

func (x *CompareBucketResponse) GetMissFrom() []string {
	if x != nil {
		return x.MissFrom
	}
	return nil
}

func (x *CompareBucketResponse) GetMissTo() []string {
	if x != nil {
		return x.MissTo
	}
	return nil
}

func (x *CompareBucketResponse) GetDiffer() []string {
	if x != nil {
		return x.Differ
	}
	return nil
}

func (x *CompareBucketResponse) GetError() []string {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *CompareBucketResponse) GetMatch() []string {
	if x != nil {
		return x.Match
	}
	return nil
}

type SwitchZeroDowntimeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Id of user- or bucket- level replication policy to switch source and
	// destination targets on proxy. Replication policy should already exist.
	// Agent-based replication is not supported.
	// Bucket-level replication with different from/to bucket names is not
	// supported.
	ReplicationId *ReplicationID `protobuf:"bytes,1,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	// Max Amount of time to wait for uncompleted multipart uploads to finish
	// before switching targets. Default is 1 hour.
	MultipartTtl  *durationpb.Duration `protobuf:"bytes,2,opt,name=multipart_ttl,json=multipartTtl,proto3,oneof" json:"multipart_ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchZeroDowntimeRequest) Reset() {
	*x = SwitchZeroDowntimeRequest{}
	mi := &file_chorus_policy_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchZeroDowntimeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchZeroDowntimeRequest) ProtoMessage() {}

func (x *SwitchZeroDowntimeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchZeroDowntimeRequest.ProtoReflect.Descriptor instead.
func (*SwitchZeroDowntimeRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{10}
}

func (x *SwitchZeroDowntimeRequest) GetReplicationId() *ReplicationID {
	if x != nil {
		return x.ReplicationId
	}
	return nil
}

func (x *SwitchZeroDowntimeRequest) GetMultipartTtl() *durationpb.Duration {
	if x != nil {
		return x.MultipartTtl
	}
	return nil
}

// Request to configure switch between replication source and destination
// with downtime window.
type SwitchDowntimeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Id of user- or bucket- level replication policy to switch source and
	// destination targets on proxy. Replication policy should already exist.
	// Agent-based replication is not supported.
	// Bucket-level replication with different from/to bucket names is not
	// supported.
	ReplicationId *ReplicationID `protobuf:"bytes,1,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	// Configures downtime window for switch. During downtime all requests to
	// target will be blocked on proxy. If options are not set, downtime will be
	// started right away and will last until all replication tasks are processed.
	DowntimeOpts  *SwitchDowntimeOpts `protobuf:"bytes,2,opt,name=downtime_opts,json=downtimeOpts,proto3,oneof" json:"downtime_opts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwitchDowntimeRequest) Reset() {
	*x = SwitchDowntimeRequest{}
	mi := &file_chorus_policy_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchDowntimeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchDowntimeRequest) ProtoMessage() {}

func (x *SwitchDowntimeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchDowntimeRequest.ProtoReflect.Descriptor instead.
func (*SwitchDowntimeRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{11}
}

func (x *SwitchDowntimeRequest) GetReplicationId() *ReplicationID {
	if x != nil {
		return x.ReplicationId
	}
	return nil
}

func (x *SwitchDowntimeRequest) GetDowntimeOpts() *SwitchDowntimeOpts {
	if x != nil {
		return x.DowntimeOpts
	}
	return nil
}

// Defines downtime window for replication switch with downtime.
// All dates and times depends on local times of machine running chorus worker.
// Time precision is ~1 minute.
type SwitchDowntimeOpts struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, chorus will perform switch automatically when initial migration
	// will be done. Initial migration copies all objects that existed in source
	// bucket before replication started. default is false
	StartOnInitDone bool `protobuf:"varint,1,opt,name=start_on_init_done,json=startOnInitDone,proto3" json:"start_on_init_done,omitempty"`
	// If set, chorus will try or retry to start downtime window according to CRON
	// schedule.
	// It is not makes sense to set cron frequency less than one hour or less than
	// max_duration if used. Either cron or start_at can be set, but not both.
	Cron *string `protobuf:"bytes,2,opt,name=cron,proto3,oneof" json:"cron,omitempty"`
	// If set, downtime window will be attempted at given time only once.
	// If at this point initial migration will not be done, switch will be marked
	// as failed and not executed. Either cron or start_at can be set, not both.
	StartAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=start_at,json=startAt,proto3,oneof" json:"start_at,omitempty"`
	// If set, chorus will abort downtime window if it will not be able to
	// complete in given time. In this case, switch will be marked as failed and
	// will be retried on next cron execution if set.
	MaxDuration *durationpb.Duration `protobuf:"bytes,4,opt,name=max_duration,json=maxDuration,proto3,oneof" json:"max_duration,omitempty"`
	// If set, switch execution will be skipped if number of unprocessed events is
	// more than max_event_lag. Switch will be marked as failed and will be
	// retried on next cron execution if set.
	MaxEventLag *uint32 `protobuf:"varint,5,opt,name=max_event_lag,json=maxEventLag,proto3,oneof" json:"max_event_lag,omitempty"`
	// if true, chorus will not perform equality check of target contents before
	// completing switch with downtime. Might be useful for buckets with large
	// number of objects. In this case check will consume a lot of time and memory
	// in Redis. Default is false.
	SkipBucketCheck bool `protobuf:"varint,6,opt,name=skip_bucket_check,json=skipBucketCheck,proto3" json:"skip_bucket_check,omitempty"`
	// Set true to replicate data updates from new main to old main bucket after
	// successful switch. Default is false.
	ContinueReplication bool `protobuf:"varint,7,opt,name=continue_replication,json=continueReplication,proto3" json:"continue_replication,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *SwitchDowntimeOpts) Reset() {
	*x = SwitchDowntimeOpts{}
	mi := &file_chorus_policy_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwitchDowntimeOpts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwitchDowntimeOpts) ProtoMessage() {}

func (x *SwitchDowntimeOpts) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwitchDowntimeOpts.ProtoReflect.Descriptor instead.
func (*SwitchDowntimeOpts) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{12}
}

func (x *SwitchDowntimeOpts) GetStartOnInitDone() bool {
	if x != nil {
		return x.StartOnInitDone
	}
	return false
}

func (x *SwitchDowntimeOpts) GetCron() string {
	if x != nil && x.Cron != nil {
		return *x.Cron
	}
	return ""
}

func (x *SwitchDowntimeOpts) GetStartAt() *timestamppb.Timestamp {
	if x != nil {
		return x.StartAt
	}
	return nil
}

func (x *SwitchDowntimeOpts) GetMaxDuration() *durationpb.Duration {
	if x != nil {
		return x.MaxDuration
	}
	return nil
}

func (x *SwitchDowntimeOpts) GetMaxEventLag() uint32 {
	if x != nil && x.MaxEventLag != nil {
		return *x.MaxEventLag
	}
	return 0
}

func (x *SwitchDowntimeOpts) GetSkipBucketCheck() bool {
	if x != nil {
		return x.SkipBucketCheck
	}
	return false
}

func (x *SwitchDowntimeOpts) GetContinueReplication() bool {
	if x != nil {
		return x.ContinueReplication
	}
	return false
}

type ReplicationSwitch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current switch status
	LastStatus ReplicationSwitch_Status `protobuf:"varint,1,opt,name=last_status,json=lastStatus,proto3,enum=chorus.ReplicationSwitch_Status" json:"last_status,omitempty"`
	// true if switch is zero downtime
	ZeroDowntime bool `protobuf:"varint,2,opt,name=zero_downtime,json=zeroDowntime,proto3" json:"zero_downtime,omitempty"`
	// multipart uploads TTL for zero downtime switch
	MultipartTtl *durationpb.Duration `protobuf:"bytes,3,opt,name=multipart_ttl,json=multipartTtl,proto3,oneof" json:"multipart_ttl,omitempty"`
	DowntimeOpts *SwitchDowntimeOpts  `protobuf:"bytes,4,opt,name=downtime_opts,json=downtimeOpts,proto3,oneof" json:"downtime_opts,omitempty"`
	// Time of last switch attempt - last time when switch was moved to InProgress
	// status.
	LastStartedAt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_started_at,json=lastStartedAt,proto3,oneof" json:"last_started_at,omitempty"`
	// Time of last switch completion. Set only if switch status is Done.
	DoneAt *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=done_at,json=doneAt,proto3,oneof" json:"done_at,omitempty"`
	// History of switch status changes
	History       []string       `protobuf:"bytes,7,rep,name=history,proto3" json:"history,omitempty"`
	ReplicationId *ReplicationID `protobuf:"bytes,8,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationSwitch) Reset() {
	*x = ReplicationSwitch{}
	mi := &file_chorus_policy_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationSwitch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationSwitch) ProtoMessage() {}

func (x *ReplicationSwitch) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationSwitch.ProtoReflect.Descriptor instead.
func (*ReplicationSwitch) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{13}
}

func (x *ReplicationSwitch) GetLastStatus() ReplicationSwitch_Status {
	if x != nil {
		return x.LastStatus
	}
	return ReplicationSwitch_NOT_STARTED
}

func (x *ReplicationSwitch) GetZeroDowntime() bool {
	if x != nil {
		return x.ZeroDowntime
	}
	return false
}

func (x *ReplicationSwitch) GetMultipartTtl() *durationpb.Duration {
	if x != nil {
		return x.MultipartTtl
	}
	return nil
}

func (x *ReplicationSwitch) GetDowntimeOpts() *SwitchDowntimeOpts {
	if x != nil {
		return x.DowntimeOpts
	}
	return nil
}

func (x *ReplicationSwitch) GetLastStartedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastStartedAt
	}
	return nil
}

func (x *ReplicationSwitch) GetDoneAt() *timestamppb.Timestamp {
	if x != nil {
		return x.DoneAt
	}
	return nil
}

func (x *ReplicationSwitch) GetHistory() []string {
	if x != nil {
		return x.History
	}
	return nil
}

func (x *ReplicationSwitch) GetReplicationId() *ReplicationID {
	if x != nil {
		return x.ReplicationId
	}
	return nil
}

type RoutingsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// set true to hide user-level routings from response
	HideUserRoutings bool `protobuf:"varint,1,opt,name=hide_user_routings,json=hideUserRoutings,proto3" json:"hide_user_routings,omitempty"`
	// set true to hide bucket-level routings from response
	HideBucketRoutings bool `protobuf:"varint,2,opt,name=hide_bucket_routings,json=hideBucketRoutings,proto3" json:"hide_bucket_routings,omitempty"`
	// optional filter to apply to routings list
	Filter        *RoutingsRequest_Filter `protobuf:"bytes,3,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoutingsRequest) Reset() {
	*x = RoutingsRequest{}
	mi := &file_chorus_policy_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingsRequest) ProtoMessage() {}

func (x *RoutingsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingsRequest.ProtoReflect.Descriptor instead.
func (*RoutingsRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{14}
}

func (x *RoutingsRequest) GetHideUserRoutings() bool {
	if x != nil {
		return x.HideUserRoutings
	}
	return false
}

func (x *RoutingsRequest) GetHideBucketRoutings() bool {
	if x != nil {
		return x.HideBucketRoutings
	}
	return false
}

func (x *RoutingsRequest) GetFilter() *RoutingsRequest_Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

type RoutingsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the main storage - default destination if not overridden by user or
	// bucket routing.
	Main string `protobuf:"bytes,1,opt,name=main,proto3" json:"main,omitempty"`
	// list of user-level routing overrides.
	UserRoutings []*UserRouting `protobuf:"bytes,2,rep,name=user_routings,json=userRoutings,proto3" json:"user_routings,omitempty"`
	// list of bucket-level routing overrides.
	BucketRoutings []*BucketRouting `protobuf:"bytes,3,rep,name=bucket_routings,json=bucketRoutings,proto3" json:"bucket_routings,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RoutingsResponse) Reset() {
	*x = RoutingsResponse{}
	mi := &file_chorus_policy_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingsResponse) ProtoMessage() {}

func (x *RoutingsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingsResponse.ProtoReflect.Descriptor instead.
func (*RoutingsResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{15}
}

func (x *RoutingsResponse) GetMain() string {
	if x != nil {
		return x.Main
	}
	return ""
}

func (x *RoutingsResponse) GetUserRoutings() []*UserRouting {
	if x != nil {
		return x.UserRoutings
	}
	return nil
}

func (x *RoutingsResponse) GetBucketRoutings() []*BucketRouting {
	if x != nil {
		return x.BucketRoutings
	}
	return nil
}

type UserRouting struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// overrides routing destination for all requests of given user.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// destination storage name
	// can be empty if routing is blocked
	ToStorage string `protobuf:"bytes,2,opt,name=to_storage,json=toStorage,proto3" json:"to_storage,omitempty"`
	// true if routing is blocked for given user
	IsBlocked     bool `protobuf:"varint,3,opt,name=is_blocked,json=isBlocked,proto3" json:"is_blocked,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserRouting) Reset() {
	*x = UserRouting{}
	mi := &file_chorus_policy_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserRouting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserRouting) ProtoMessage() {}

func (x *UserRouting) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserRouting.ProtoReflect.Descriptor instead.
func (*UserRouting) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{16}
}

func (x *UserRouting) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *UserRouting) GetToStorage() string {
	if x != nil {
		return x.ToStorage
	}
	return ""
}

func (x *UserRouting) GetIsBlocked() bool {
	if x != nil {
		return x.IsBlocked
	}
	return false
}

type BucketRouting struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// overrides routing destination for given user and bucket.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// overrides routing destination for given user and bucket.
	Bucket string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// destination storage name
	// can be empty if routing is blocked
	ToStorage string `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3" json:"to_storage,omitempty"`
	// true if routing is blocked for given user and bucket
	IsBlocked     bool `protobuf:"varint,4,opt,name=is_blocked,json=isBlocked,proto3" json:"is_blocked,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BucketRouting) Reset() {
	*x = BucketRouting{}
	mi := &file_chorus_policy_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BucketRouting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BucketRouting) ProtoMessage() {}

func (x *BucketRouting) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BucketRouting.ProtoReflect.Descriptor instead.
func (*BucketRouting) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{17}
}

func (x *BucketRouting) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *BucketRouting) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

func (x *BucketRouting) GetToStorage() string {
	if x != nil {
		return x.ToStorage
	}
	return ""
}

func (x *BucketRouting) GetIsBlocked() bool {
	if x != nil {
		return x.IsBlocked
	}
	return false
}

type AddRoutingRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// user for whom to override routing destination.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// bucket for which to override routing destination.
	Bucket *string `protobuf:"bytes,2,opt,name=bucket,proto3,oneof" json:"bucket,omitempty"`
	// destination storage name
	ToStorage     string `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3" json:"to_storage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddRoutingRequest) Reset() {
	*x = AddRoutingRequest{}
	mi := &file_chorus_policy_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddRoutingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddRoutingRequest) ProtoMessage() {}

func (x *AddRoutingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddRoutingRequest.ProtoReflect.Descriptor instead.
func (*AddRoutingRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{18}
}

func (x *AddRoutingRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *AddRoutingRequest) GetBucket() string {
	if x != nil && x.Bucket != nil {
		return *x.Bucket
	}
	return ""
}

func (x *AddRoutingRequest) GetToStorage() string {
	if x != nil {
		return x.ToStorage
	}
	return ""
}

type RoutingID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// routing policy user
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// routing policy bucket
	Bucket        *string `protobuf:"bytes,2,opt,name=bucket,proto3,oneof" json:"bucket,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoutingID) Reset() {
	*x = RoutingID{}
	mi := &file_chorus_policy_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingID) ProtoMessage() {}

func (x *RoutingID) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingID.ProtoReflect.Descriptor instead.
func (*RoutingID) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{19}
}

func (x *RoutingID) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *RoutingID) GetBucket() string {
	if x != nil && x.Bucket != nil {
		return *x.Bucket
	}
	return ""
}

type TestProxyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// user making requests
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// bucket being accessed
	Bucket        string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TestProxyRequest) Reset() {
	*x = TestProxyRequest{}
	mi := &file_chorus_policy_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestProxyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestProxyRequest) ProtoMessage() {}

func (x *TestProxyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestProxyRequest.ProtoReflect.Descriptor instead.
func (*TestProxyRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{20}
}

func (x *TestProxyRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *TestProxyRequest) GetBucket() string {
	if x != nil {
		return x.Bucket
	}
	return ""
}

type TestProxyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// destination storage name according to current routing configuration.
	RouteToStorage string `protobuf:"bytes,1,opt,name=route_to_storage,json=routeToStorage,proto3" json:"route_to_storage,omitempty"`
	// true if requests are blocked for given user and bucket.
	IsBlocked bool `protobuf:"varint,2,opt,name=is_blocked,json=isBlocked,proto3" json:"is_blocked,omitempty"`
	// list of applicable replications for given user and bucket.
	Replications  []*ReplicationID `protobuf:"bytes,3,rep,name=replications,proto3" json:"replications,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TestProxyResponse) Reset() {
	*x = TestProxyResponse{}
	mi := &file_chorus_policy_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TestProxyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TestProxyResponse) ProtoMessage() {}

func (x *TestProxyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TestProxyResponse.ProtoReflect.Descriptor instead.
func (*TestProxyResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{21}
}

func (x *TestProxyResponse) GetRouteToStorage() string {
	if x != nil {
		return x.RouteToStorage
	}
	return ""
}

func (x *TestProxyResponse) GetIsBlocked() bool {
	if x != nil {
		return x.IsBlocked
	}
	return false
}

func (x *TestProxyResponse) GetReplications() []*ReplicationID {
	if x != nil {
		return x.Replications
	}
	return nil
}

type ReplicationDiffRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Id of bucket-level replication to get diff for.
	ReplicationId *ReplicationID `protobuf:"bytes,1,opt,name=replication_id,json=replicationId,proto3" json:"replication_id,omitempty"`
	// if true, only last versions of versioned objects will be compared
	// ignored if diff already exists
	CheckOnlyLastVersions bool `protobuf:"varint,2,opt,name=check_only_last_versions,json=checkOnlyLastVersions,proto3" json:"check_only_last_versions,omitempty"`
	// if true, etags will be ignored during comparison
	// ignored if diff already exists
	IgnoreEtags bool `protobuf:"varint,3,opt,name=ignore_etags,json=ignoreEtags,proto3" json:"ignore_etags,omitempty"`
	// if true, sizes will be ignored during comparison
	// ignored if diff already exists
	IgnoreSizes   bool `protobuf:"varint,4,opt,name=ignore_sizes,json=ignoreSizes,proto3" json:"ignore_sizes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationDiffRequest) Reset() {
	*x = ReplicationDiffRequest{}
	mi := &file_chorus_policy_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationDiffRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationDiffRequest) ProtoMessage() {}

func (x *ReplicationDiffRequest) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationDiffRequest.ProtoReflect.Descriptor instead.
func (*ReplicationDiffRequest) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{22}
}

func (x *ReplicationDiffRequest) GetReplicationId() *ReplicationID {
	if x != nil {
		return x.ReplicationId
	}
	return nil
}

func (x *ReplicationDiffRequest) GetCheckOnlyLastVersions() bool {
	if x != nil {
		return x.CheckOnlyLastVersions
	}
	return false
}

func (x *ReplicationDiffRequest) GetIgnoreEtags() bool {
	if x != nil {
		return x.IgnoreEtags
	}
	return false
}

func (x *ReplicationDiffRequest) GetIgnoreSizes() bool {
	if x != nil {
		return x.IgnoreSizes
	}
	return false
}

// Response for replication diff request.
type ReplicationDiffResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// true if diff calculation is completed and report is ready
	// if false, diff is still being calculated, try again later
	IsReady bool `protobuf:"varint,1,opt,name=is_ready,json=isReady,proto3" json:"is_ready,omitempty"`
	// true if storage's buckets have the same content
	IsMatch bool `protobuf:"varint,2,opt,name=is_match,json=isMatch,proto3" json:"is_match,omitempty"`
	// list of missing objects in 'from storage' bucket
	// shows first 1000 of miss_from + miss_to + differ objects
	MissFrom []string `protobuf:"bytes,3,rep,name=miss_from,json=missFrom,proto3" json:"miss_from,omitempty"`
	// list of missing objects in 'to storage' bucket
	// shows first 1000 of miss_from + miss_to + differ objects
	MissTo []string `protobuf:"bytes,4,rep,name=miss_to,json=missTo,proto3" json:"miss_to,omitempty"`
	// list of objects with different content based on size/etag
	// shows first 1000 of miss_from + miss_to + differ objects
	Differ        []string `protobuf:"bytes,5,rep,name=differ,proto3" json:"differ,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationDiffResponse) Reset() {
	*x = ReplicationDiffResponse{}
	mi := &file_chorus_policy_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationDiffResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationDiffResponse) ProtoMessage() {}

func (x *ReplicationDiffResponse) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationDiffResponse.ProtoReflect.Descriptor instead.
func (*ReplicationDiffResponse) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{23}
}

func (x *ReplicationDiffResponse) GetIsReady() bool {
	if x != nil {
		return x.IsReady
	}
	return false
}

func (x *ReplicationDiffResponse) GetIsMatch() bool {
	if x != nil {
		return x.IsMatch
	}
	return false
}

func (x *ReplicationDiffResponse) GetMissFrom() []string {
	if x != nil {
		return x.MissFrom
	}
	return nil
}

func (x *ReplicationDiffResponse) GetMissTo() []string {
	if x != nil {
		return x.MissTo
	}
	return nil
}

func (x *ReplicationDiffResponse) GetDiffer() []string {
	if x != nil {
		return x.Differ
	}
	return nil
}

type ListReplicationsRequest_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If set, filters replications by exact user.
	User *string `protobuf:"bytes,1,opt,name=user,proto3,oneof" json:"user,omitempty"`
	// If set, filters replications by exact source storage.
	FromStorage *string `protobuf:"bytes,2,opt,name=from_storage,json=fromStorage,proto3,oneof" json:"from_storage,omitempty"`
	// If set, filters replications by exact destination storage.
	ToStorage *string `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3,oneof" json:"to_storage,omitempty"`
	// If set, filters bucket-level replications by exact source bucket.
	FromBucket *string `protobuf:"bytes,4,opt,name=from_bucket,json=fromBucket,proto3,oneof" json:"from_bucket,omitempty"`
	// If set, filters bucket-level replications by exact destination bucket.
	ToBucket *string `protobuf:"bytes,5,opt,name=to_bucket,json=toBucket,proto3,oneof" json:"to_bucket,omitempty"`
	// If set, filters replications by archived status.
	IsArchived *bool `protobuf:"varint,6,opt,name=is_archived,json=isArchived,proto3,oneof" json:"is_archived,omitempty"`
	// If set, filters replications by paused status.
	IsPaused *bool `protobuf:"varint,7,opt,name=is_paused,json=isPaused,proto3,oneof" json:"is_paused,omitempty"`
	// If set, filters replications by completion of initial replication phase.
	IsInitDone *bool `protobuf:"varint,8,opt,name=is_init_done,json=isInitDone,proto3,oneof" json:"is_init_done,omitempty"`
	// If set, filters replications that have or not have associated switch.
	HasSwitch *bool `protobuf:"varint,9,opt,name=has_switch,json=hasSwitch,proto3,oneof" json:"has_switch,omitempty"`
	// If set, filters replications by agent-based or proxy-based replication.
	IsAgent       *bool `protobuf:"varint,10,opt,name=is_agent,json=isAgent,proto3,oneof" json:"is_agent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListReplicationsRequest_Filter) Reset() {
	*x = ListReplicationsRequest_Filter{}
	mi := &file_chorus_policy_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListReplicationsRequest_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListReplicationsRequest_Filter) ProtoMessage() {}

func (x *ListReplicationsRequest_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListReplicationsRequest_Filter.ProtoReflect.Descriptor instead.
func (*ListReplicationsRequest_Filter) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{3, 0}
}

func (x *ListReplicationsRequest_Filter) GetUser() string {
	if x != nil && x.User != nil {
		return *x.User
	}
	return ""
}

func (x *ListReplicationsRequest_Filter) GetFromStorage() string {
	if x != nil && x.FromStorage != nil {
		return *x.FromStorage
	}
	return ""
}

func (x *ListReplicationsRequest_Filter) GetToStorage() string {
	if x != nil && x.ToStorage != nil {
		return *x.ToStorage
	}
	return ""
}

func (x *ListReplicationsRequest_Filter) GetFromBucket() string {
	if x != nil && x.FromBucket != nil {
		return *x.FromBucket
	}
	return ""
}

func (x *ListReplicationsRequest_Filter) GetToBucket() string {
	if x != nil && x.ToBucket != nil {
		return *x.ToBucket
	}
	return ""
}

func (x *ListReplicationsRequest_Filter) GetIsArchived() bool {
	if x != nil && x.IsArchived != nil {
		return *x.IsArchived
	}
	return false
}

func (x *ListReplicationsRequest_Filter) GetIsPaused() bool {
	if x != nil && x.IsPaused != nil {
		return *x.IsPaused
	}
	return false
}

func (x *ListReplicationsRequest_Filter) GetIsInitDone() bool {
	if x != nil && x.IsInitDone != nil {
		return *x.IsInitDone
	}
	return false
}

func (x *ListReplicationsRequest_Filter) GetHasSwitch() bool {
	if x != nil && x.HasSwitch != nil {
		return *x.HasSwitch
	}
	return false
}

func (x *ListReplicationsRequest_Filter) GetIsAgent() bool {
	if x != nil && x.IsAgent != nil {
		return *x.IsAgent
	}
	return false
}

type RoutingsRequest_Filter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// filter routing policy by user (exact match)
	User *string `protobuf:"bytes,1,opt,name=user,proto3,oneof" json:"user,omitempty"`
	// filter routing policy by bucket (exact match)
	Bucket *string `protobuf:"bytes,2,opt,name=bucket,proto3,oneof" json:"bucket,omitempty"`
	// filter routing policy by destination storage (exact match)
	ToStorage *string `protobuf:"bytes,3,opt,name=to_storage,json=toStorage,proto3,oneof" json:"to_storage,omitempty"`
	// filter routing policy by blocked status
	IsBlocked     *bool `protobuf:"varint,4,opt,name=is_blocked,json=isBlocked,proto3,oneof" json:"is_blocked,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoutingsRequest_Filter) Reset() {
	*x = RoutingsRequest_Filter{}
	mi := &file_chorus_policy_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingsRequest_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingsRequest_Filter) ProtoMessage() {}

func (x *RoutingsRequest_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_chorus_policy_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingsRequest_Filter.ProtoReflect.Descriptor instead.
func (*RoutingsRequest_Filter) Descriptor() ([]byte, []int) {
	return file_chorus_policy_proto_rawDescGZIP(), []int{14, 0}
}

func (x *RoutingsRequest_Filter) GetUser() string {
	if x != nil && x.User != nil {
		return *x.User
	}
	return ""
}

func (x *RoutingsRequest_Filter) GetBucket() string {
	if x != nil && x.Bucket != nil {
		return *x.Bucket
	}
	return ""
}

func (x *RoutingsRequest_Filter) GetToStorage() string {
	if x != nil && x.ToStorage != nil {
		return *x.ToStorage
	}
	return ""
}

func (x *RoutingsRequest_Filter) GetIsBlocked() bool {
	if x != nil && x.IsBlocked != nil {
		return *x.IsBlocked
	}
	return false
}

var File_chorus_policy_proto protoreflect.FileDescriptor

const file_chorus_policy_proto_rawDesc = "" +
	"\n" +
	"\x13chorus/policy.proto\x12\x06chorus\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xcb\x01\n" +
	"\rReplicationID\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12!\n" +
	"\ffrom_storage\x18\x02 \x01(\tR\vfromStorage\x12\x1d\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tR\ttoStorage\x12$\n" +
	"\vfrom_bucket\x18\x04 \x01(\tH\x00R\n" +
	"fromBucket\x88\x01\x01\x12 \n" +
	"\tto_bucket\x18\x05 \x01(\tH\x01R\btoBucket\x88\x01\x01B\x0e\n" +
	"\f_from_bucketB\f\n" +
	"\n" +
	"_to_bucket\"k\n" +
	"\x15AddReplicationRequest\x12%\n" +
	"\x02id\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\x02id\x12+\n" +
	"\x04opts\x18\x02 \x01(\v2\x17.chorus.ReplicationOptsR\x04opts\"A\n" +
	"\x0fReplicationOpts\x12 \n" +
	"\tagent_url\x18\x01 \x01(\tH\x00R\bagentUrl\x88\x01\x01B\f\n" +
	"\n" +
	"_agent_url\"\xf0\x05\n" +
	"\x17ListReplicationsRequest\x124\n" +
	"\x16hide_user_replications\x18\x01 \x01(\bR\x14hideUserReplications\x128\n" +
	"\x18hide_bucket_replications\x18\x02 \x01(\bR\x16hideBucketReplications\x12(\n" +
	"\x10hide_switch_info\x18\x03 \x01(\bR\x0ehideSwitchInfo\x12>\n" +
	"\x06filter\x18\x04 \x01(\v2&.chorus.ListReplicationsRequest.FilterR\x06filter\x1a\xfa\x03\n" +
	"\x06Filter\x12\x17\n" +
	"\x04user\x18\x01 \x01(\tH\x00R\x04user\x88\x01\x01\x12&\n" +
	"\ffrom_storage\x18\x02 \x01(\tH\x01R\vfromStorage\x88\x01\x01\x12\"\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tH\x02R\ttoStorage\x88\x01\x01\x12$\n" +
	"\vfrom_bucket\x18\x04 \x01(\tH\x03R\n" +
	"fromBucket\x88\x01\x01\x12 \n" +
	"\tto_bucket\x18\x05 \x01(\tH\x04R\btoBucket\x88\x01\x01\x12$\n" +
	"\vis_archived\x18\x06 \x01(\bH\x05R\n" +
	"isArchived\x88\x01\x01\x12 \n" +
	"\tis_paused\x18\a \x01(\bH\x06R\bisPaused\x88\x01\x01\x12%\n" +
	"\fis_init_done\x18\b \x01(\bH\aR\n" +
	"isInitDone\x88\x01\x01\x12\"\n" +
	"\n" +
	"has_switch\x18\t \x01(\bH\bR\thasSwitch\x88\x01\x01\x12\x1e\n" +
	"\bis_agent\x18\n" +
	" \x01(\bH\tR\aisAgent\x88\x01\x01B\a\n" +
	"\x05_userB\x0f\n" +
	"\r_from_storageB\r\n" +
	"\v_to_storageB\x0e\n" +
	"\f_from_bucketB\f\n" +
	"\n" +
	"_to_bucketB\x0e\n" +
	"\f_is_archivedB\f\n" +
	"\n" +
	"_is_pausedB\x0f\n" +
	"\r_is_init_doneB\r\n" +
	"\v_has_switchB\v\n" +
	"\t_is_agent\"S\n" +
	"\x18ListReplicationsResponse\x127\n" +
	"\freplications\x18\x01 \x03(\v2\x13.chorus.ReplicationR\freplications\"\xe6\x04\n" +
	"\vReplication\x12%\n" +
	"\x02id\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\x02id\x12+\n" +
	"\x04opts\x18\x02 \x01(\v2\x17.chorus.ReplicationOptsR\x04opts\x129\n" +
	"\n" +
	"created_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\x1b\n" +
	"\tis_paused\x18\x04 \x01(\bR\bisPaused\x12 \n" +
	"\fis_init_done\x18\x05 \x01(\bR\n" +
	"isInitDone\x12&\n" +
	"\x0finit_obj_listed\x18\x06 \x01(\x03R\rinitObjListed\x12\"\n" +
	"\rinit_obj_done\x18\a \x01(\x03R\vinitObjDone\x12\x16\n" +
	"\x06events\x18\b \x01(\x03R\x06events\x12\x1f\n" +
	"\vevents_done\x18\t \x01(\x03R\n" +
	"eventsDone\x126\n" +
	"\tevent_lag\x18\n" +
	" \x01(\v2\x19.google.protobuf.DurationR\beventLag\x12\x1d\n" +
	"\n" +
	"has_switch\x18\v \x01(\bR\thasSwitch\x12\x1f\n" +
	"\vis_archived\x18\f \x01(\bR\n" +
	"isArchived\x12;\n" +
	"\varchived_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"archivedAt\x12?\n" +
	"\vswitch_info\x18\x0e \x01(\v2\x19.chorus.ReplicationSwitchH\x00R\n" +
	"switchInfo\x88\x01\x01B\x0e\n" +
	"\f_switch_info\"\x98\x01\n" +
	"\x17AvailableBucketsRequest\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12!\n" +
	"\ffrom_storage\x18\x02 \x01(\tR\vfromStorage\x12\x1d\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tR\ttoStorage\x12'\n" +
	"\x0fshow_replicated\x18\x04 \x01(\bR\x0eshowReplicated\"c\n" +
	"\x18AvailableBucketsResponse\x12\x18\n" +
	"\abuckets\x18\x01 \x03(\tR\abuckets\x12-\n" +
	"\x12replicated_buckets\x18\x02 \x03(\tR\x11replicatedBuckets\"d\n" +
	"\x14CompareBucketRequest\x12-\n" +
	"\x06target\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\x06target\x12\x1d\n" +
	"\n" +
	"show_match\x18\x02 \x01(\bR\tshowMatch\"\xac\x01\n" +
	"\x15CompareBucketResponse\x12\x19\n" +
	"\bis_match\x18\x01 \x01(\bR\aisMatch\x12\x1b\n" +
	"\tmiss_from\x18\x02 \x03(\tR\bmissFrom\x12\x17\n" +
	"\amiss_to\x18\x03 \x03(\tR\x06missTo\x12\x16\n" +
	"\x06differ\x18\x04 \x03(\tR\x06differ\x12\x14\n" +
	"\x05error\x18\x05 \x03(\tR\x05error\x12\x14\n" +
	"\x05match\x18\x06 \x03(\tR\x05match\"\xb0\x01\n" +
	"\x19SwitchZeroDowntimeRequest\x12<\n" +
	"\x0ereplication_id\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\rreplicationId\x12C\n" +
	"\rmultipart_ttl\x18\x02 \x01(\v2\x19.google.protobuf.DurationH\x00R\fmultipartTtl\x88\x01\x01B\x10\n" +
	"\x0e_multipart_ttl\"\xad\x01\n" +
	"\x15SwitchDowntimeRequest\x12<\n" +
	"\x0ereplication_id\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\rreplicationId\x12D\n" +
	"\rdowntime_opts\x18\x02 \x01(\v2\x1a.chorus.SwitchDowntimeOptsH\x00R\fdowntimeOpts\x88\x01\x01B\x10\n" +
	"\x0e_downtime_opts\"\x9a\x03\n" +
	"\x12SwitchDowntimeOpts\x12+\n" +
	"\x12start_on_init_done\x18\x01 \x01(\bR\x0fstartOnInitDone\x12\x17\n" +
	"\x04cron\x18\x02 \x01(\tH\x00R\x04cron\x88\x01\x01\x12:\n" +
	"\bstart_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampH\x01R\astartAt\x88\x01\x01\x12A\n" +
	"\fmax_duration\x18\x04 \x01(\v2\x19.google.protobuf.DurationH\x02R\vmaxDuration\x88\x01\x01\x12'\n" +
	"\rmax_event_lag\x18\x05 \x01(\rH\x03R\vmaxEventLag\x88\x01\x01\x12*\n" +
	"\x11skip_bucket_check\x18\x06 \x01(\bR\x0fskipBucketCheck\x121\n" +
	"\x14continue_replication\x18\a \x01(\bR\x13continueReplicationB\a\n" +
	"\x05_cronB\v\n" +
	"\t_start_atB\x0f\n" +
	"\r_max_durationB\x10\n" +
	"\x0e_max_event_lag\"\x8a\x05\n" +
	"\x11ReplicationSwitch\x12A\n" +
	"\vlast_status\x18\x01 \x01(\x0e2 .chorus.ReplicationSwitch.StatusR\n" +
	"lastStatus\x12#\n" +
	"\rzero_downtime\x18\x02 \x01(\bR\fzeroDowntime\x12C\n" +
	"\rmultipart_ttl\x18\x03 \x01(\v2\x19.google.protobuf.DurationH\x00R\fmultipartTtl\x88\x01\x01\x12D\n" +
	"\rdowntime_opts\x18\x04 \x01(\v2\x1a.chorus.SwitchDowntimeOptsH\x01R\fdowntimeOpts\x88\x01\x01\x12G\n" +
	"\x0flast_started_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x02R\rlastStartedAt\x88\x01\x01\x128\n" +
	"\adone_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampH\x03R\x06doneAt\x88\x01\x01\x12\x18\n" +
	"\ahistory\x18\a \x03(\tR\ahistory\x12<\n" +
	"\x0ereplication_id\x18\b \x01(\v2\x15.chorus.ReplicationIDR\rreplicationId\"c\n" +
	"\x06Status\x12\x0f\n" +
	"\vNOT_STARTED\x10\x00\x12\x0f\n" +
	"\vIN_PROGRESS\x10\x01\x12\x15\n" +
	"\x11CHECK_IN_PROGRESS\x10\x02\x12\t\n" +
	"\x05ERROR\x10\x03\x12\v\n" +
	"\aSKIPPED\x10\x04\x12\b\n" +
	"\x04DONE\x10\x05B\x10\n" +
	"\x0e_multipart_ttlB\x10\n" +
	"\x0e_downtime_optsB\x12\n" +
	"\x10_last_started_atB\n" +
	"\n" +
	"\b_done_at\"\xf4\x02\n" +
	"\x0fRoutingsRequest\x12,\n" +
	"\x12hide_user_routings\x18\x01 \x01(\bR\x10hideUserRoutings\x120\n" +
	"\x14hide_bucket_routings\x18\x02 \x01(\bR\x12hideBucketRoutings\x12;\n" +
	"\x06filter\x18\x03 \x01(\v2\x1e.chorus.RoutingsRequest.FilterH\x00R\x06filter\x88\x01\x01\x1a\xb8\x01\n" +
	"\x06Filter\x12\x17\n" +
	"\x04user\x18\x01 \x01(\tH\x00R\x04user\x88\x01\x01\x12\x1b\n" +
	"\x06bucket\x18\x02 \x01(\tH\x01R\x06bucket\x88\x01\x01\x12\"\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tH\x02R\ttoStorage\x88\x01\x01\x12\"\n" +
	"\n" +
	"is_blocked\x18\x04 \x01(\bH\x03R\tisBlocked\x88\x01\x01B\a\n" +
	"\x05_userB\t\n" +
	"\a_bucketB\r\n" +
	"\v_to_storageB\r\n" +
	"\v_is_blockedB\t\n" +
	"\a_filter\"\xa0\x01\n" +
	"\x10RoutingsResponse\x12\x12\n" +
	"\x04main\x18\x01 \x01(\tR\x04main\x128\n" +
	"\ruser_routings\x18\x02 \x03(\v2\x13.chorus.UserRoutingR\fuserRoutings\x12>\n" +
	"\x0fbucket_routings\x18\x03 \x03(\v2\x15.chorus.BucketRoutingR\x0ebucketRoutings\"_\n" +
	"\vUserRouting\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x1d\n" +
	"\n" +
	"to_storage\x18\x02 \x01(\tR\ttoStorage\x12\x1d\n" +
	"\n" +
	"is_blocked\x18\x03 \x01(\bR\tisBlocked\"y\n" +
	"\rBucketRouting\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\x12\x1d\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tR\ttoStorage\x12\x1d\n" +
	"\n" +
	"is_blocked\x18\x04 \x01(\bR\tisBlocked\"n\n" +
	"\x11AddRoutingRequest\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x1b\n" +
	"\x06bucket\x18\x02 \x01(\tH\x00R\x06bucket\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"to_storage\x18\x03 \x01(\tR\ttoStorageB\t\n" +
	"\a_bucket\"G\n" +
	"\tRoutingID\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x1b\n" +
	"\x06bucket\x18\x02 \x01(\tH\x00R\x06bucket\x88\x01\x01B\t\n" +
	"\a_bucket\">\n" +
	"\x10TestProxyRequest\x12\x12\n" +
	"\x04user\x18\x01 \x01(\tR\x04user\x12\x16\n" +
	"\x06bucket\x18\x02 \x01(\tR\x06bucket\"\x97\x01\n" +
	"\x11TestProxyResponse\x12(\n" +
	"\x10route_to_storage\x18\x01 \x01(\tR\x0erouteToStorage\x12\x1d\n" +
	"\n" +
	"is_blocked\x18\x02 \x01(\bR\tisBlocked\x129\n" +
	"\freplications\x18\x03 \x03(\v2\x15.chorus.ReplicationIDR\freplications\"\xd5\x01\n" +
	"\x16ReplicationDiffRequest\x12<\n" +
	"\x0ereplication_id\x18\x01 \x01(\v2\x15.chorus.ReplicationIDR\rreplicationId\x127\n" +
	"\x18check_only_last_versions\x18\x02 \x01(\bR\x15checkOnlyLastVersions\x12!\n" +
	"\fignore_etags\x18\x03 \x01(\bR\vignoreEtags\x12!\n" +
	"\fignore_sizes\x18\x04 \x01(\bR\vignoreSizes\"\x9d\x01\n" +
	"\x17ReplicationDiffResponse\x12\x19\n" +
	"\bis_ready\x18\x01 \x01(\bR\aisReady\x12\x19\n" +
	"\bis_match\x18\x02 \x01(\bR\aisMatch\x12\x1b\n" +
	"\tmiss_from\x18\x03 \x03(\tR\bmissFrom\x12\x17\n" +
	"\amiss_to\x18\x04 \x03(\tR\x06missTo\x12\x16\n" +
	"\x06differ\x18\x05 \x03(\tR\x06differ2\x8b\v\n" +
	"\x06Policy\x12U\n" +
	"\x10AvailableBuckets\x12\x1f.chorus.AvailableBucketsRequest\x1a .chorus.AvailableBucketsResponse\x12G\n" +
	"\x0eAddReplication\x12\x1d.chorus.AddReplicationRequest\x1a\x16.google.protobuf.Empty\x12<\n" +
	"\x0eGetReplication\x12\x15.chorus.ReplicationID\x1a\x13.chorus.Replication\x12U\n" +
	"\x10ListReplications\x12\x1f.chorus.ListReplicationsRequest\x1a .chorus.ListReplicationsResponse\x12A\n" +
	"\x11StreamReplication\x12\x15.chorus.ReplicationID\x1a\x13.chorus.Replication0\x01\x12A\n" +
	"\x10PauseReplication\x12\x15.chorus.ReplicationID\x1a\x16.google.protobuf.Empty\x12B\n" +
	"\x11ResumeReplication\x12\x15.chorus.ReplicationID\x1a\x16.google.protobuf.Empty\x12B\n" +
	"\x11DeleteReplication\x12\x15.chorus.ReplicationID\x1a\x16.google.protobuf.Empty\x12S\n" +
	"\x16SwitchWithZeroDowntime\x12!.chorus.SwitchZeroDowntimeRequest\x1a\x16.google.protobuf.Empty\x12K\n" +
	"\x12SwitchWithDowntime\x12\x1d.chorus.SwitchDowntimeRequest\x1a\x16.google.protobuf.Empty\x12=\n" +
	"\fDeleteSwitch\x12\x15.chorus.ReplicationID\x1a\x16.google.protobuf.Empty\x12C\n" +
	"\x0fGetSwitchStatus\x12\x15.chorus.ReplicationID\x1a\x19.chorus.ReplicationSwitch\x12T\n" +
	"\x0fReplicationDiff\x12\x1e.chorus.ReplicationDiffRequest\x1a\x1f.chorus.ReplicationDiffResponse\"\x00\x12H\n" +
	"\x15DeleteReplicationDiff\x12\x15.chorus.ReplicationID\x1a\x16.google.protobuf.Empty\"\x00\x12A\n" +
	"\fListRoutings\x12\x17.chorus.RoutingsRequest\x1a\x18.chorus.RoutingsResponse\x12?\n" +
	"\n" +
	"AddRouting\x12\x19.chorus.AddRoutingRequest\x1a\x16.google.protobuf.Empty\x12:\n" +
	"\rDeleteRouting\x12\x11.chorus.RoutingID\x1a\x16.google.protobuf.Empty\x129\n" +
	"\fBlockRouting\x12\x11.chorus.RoutingID\x1a\x16.google.protobuf.Empty\x12;\n" +
	"\x0eUnblockRouting\x12\x11.chorus.RoutingID\x1a\x16.google.protobuf.Empty\x12@\n" +
	"\tTestProxy\x12\x18.chorus.TestProxyRequest\x1a\x19.chorus.TestProxyResponseB)Z'github.com/clyso/chorus/proto/chorus;pbb\x06proto3"

var (
	file_chorus_policy_proto_rawDescOnce sync.Once
	file_chorus_policy_proto_rawDescData []byte
)

func file_chorus_policy_proto_rawDescGZIP() []byte {
	file_chorus_policy_proto_rawDescOnce.Do(func() {
		file_chorus_policy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_chorus_policy_proto_rawDesc), len(file_chorus_policy_proto_rawDesc)))
	})
	return file_chorus_policy_proto_rawDescData
}

var file_chorus_policy_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_chorus_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 26)
var file_chorus_policy_proto_goTypes = []any{
	(ReplicationSwitch_Status)(0),          // 0: chorus.ReplicationSwitch.Status
	(*ReplicationID)(nil),                  // 1: chorus.ReplicationID
	(*AddReplicationRequest)(nil),          // 2: chorus.AddReplicationRequest
	(*ReplicationOpts)(nil),                // 3: chorus.ReplicationOpts
	(*ListReplicationsRequest)(nil),        // 4: chorus.ListReplicationsRequest
	(*ListReplicationsResponse)(nil),       // 5: chorus.ListReplicationsResponse
	(*Replication)(nil),                    // 6: chorus.Replication
	(*AvailableBucketsRequest)(nil),        // 7: chorus.AvailableBucketsRequest
	(*AvailableBucketsResponse)(nil),       // 8: chorus.AvailableBucketsResponse
	(*CompareBucketRequest)(nil),           // 9: chorus.CompareBucketRequest
	(*CompareBucketResponse)(nil),          // 10: chorus.CompareBucketResponse
	(*SwitchZeroDowntimeRequest)(nil),      // 11: chorus.SwitchZeroDowntimeRequest
	(*SwitchDowntimeRequest)(nil),          // 12: chorus.SwitchDowntimeRequest
	(*SwitchDowntimeOpts)(nil),             // 13: chorus.SwitchDowntimeOpts
	(*ReplicationSwitch)(nil),              // 14: chorus.ReplicationSwitch
	(*RoutingsRequest)(nil),                // 15: chorus.RoutingsRequest
	(*RoutingsResponse)(nil),               // 16: chorus.RoutingsResponse
	(*UserRouting)(nil),                    // 17: chorus.UserRouting
	(*BucketRouting)(nil),                  // 18: chorus.BucketRouting
	(*AddRoutingRequest)(nil),              // 19: chorus.AddRoutingRequest
	(*RoutingID)(nil),                      // 20: chorus.RoutingID
	(*TestProxyRequest)(nil),               // 21: chorus.TestProxyRequest
	(*TestProxyResponse)(nil),              // 22: chorus.TestProxyResponse
	(*ReplicationDiffRequest)(nil),         // 23: chorus.ReplicationDiffRequest
	(*ReplicationDiffResponse)(nil),        // 24: chorus.ReplicationDiffResponse
	(*ListReplicationsRequest_Filter)(nil), // 25: chorus.ListReplicationsRequest.Filter
	(*RoutingsRequest_Filter)(nil),         // 26: chorus.RoutingsRequest.Filter
	(*timestamppb.Timestamp)(nil),          // 27: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),            // 28: google.protobuf.Duration
	(*emptypb.Empty)(nil),                  // 29: google.protobuf.Empty
}
var file_chorus_policy_proto_depIdxs = []int32{
	1,  // 0: chorus.AddReplicationRequest.id:type_name -> chorus.ReplicationID
	3,  // 1: chorus.AddReplicationRequest.opts:type_name -> chorus.ReplicationOpts
	25, // 2: chorus.ListReplicationsRequest.filter:type_name -> chorus.ListReplicationsRequest.Filter
	6,  // 3: chorus.ListReplicationsResponse.replications:type_name -> chorus.Replication
	1,  // 4: chorus.Replication.id:type_name -> chorus.ReplicationID
	3,  // 5: chorus.Replication.opts:type_name -> chorus.ReplicationOpts
	27, // 6: chorus.Replication.created_at:type_name -> google.protobuf.Timestamp
	28, // 7: chorus.Replication.event_lag:type_name -> google.protobuf.Duration
	27, // 8: chorus.Replication.archived_at:type_name -> google.protobuf.Timestamp
	14, // 9: chorus.Replication.switch_info:type_name -> chorus.ReplicationSwitch
	1,  // 10: chorus.CompareBucketRequest.target:type_name -> chorus.ReplicationID
	1,  // 11: chorus.SwitchZeroDowntimeRequest.replication_id:type_name -> chorus.ReplicationID
	28, // 12: chorus.SwitchZeroDowntimeRequest.multipart_ttl:type_name -> google.protobuf.Duration
	1,  // 13: chorus.SwitchDowntimeRequest.replication_id:type_name -> chorus.ReplicationID
	13, // 14: chorus.SwitchDowntimeRequest.downtime_opts:type_name -> chorus.SwitchDowntimeOpts
	27, // 15: chorus.SwitchDowntimeOpts.start_at:type_name -> google.protobuf.Timestamp
	28, // 16: chorus.SwitchDowntimeOpts.max_duration:type_name -> google.protobuf.Duration
	0,  // 17: chorus.ReplicationSwitch.last_status:type_name -> chorus.ReplicationSwitch.Status
	28, // 18: chorus.ReplicationSwitch.multipart_ttl:type_name -> google.protobuf.Duration
	13, // 19: chorus.ReplicationSwitch.downtime_opts:type_name -> chorus.SwitchDowntimeOpts
	27, // 20: chorus.ReplicationSwitch.last_started_at:type_name -> google.protobuf.Timestamp
	27, // 21: chorus.ReplicationSwitch.done_at:type_name -> google.protobuf.Timestamp
	1,  // 22: chorus.ReplicationSwitch.replication_id:type_name -> chorus.ReplicationID
	26, // 23: chorus.RoutingsRequest.filter:type_name -> chorus.RoutingsRequest.Filter
	17, // 24: chorus.RoutingsResponse.user_routings:type_name -> chorus.UserRouting
	18, // 25: chorus.RoutingsResponse.bucket_routings:type_name -> chorus.BucketRouting
	1,  // 26: chorus.TestProxyResponse.replications:type_name -> chorus.ReplicationID
	1,  // 27: chorus.ReplicationDiffRequest.replication_id:type_name -> chorus.ReplicationID
	7,  // 28: chorus.Policy.AvailableBuckets:input_type -> chorus.AvailableBucketsRequest
	2,  // 29: chorus.Policy.AddReplication:input_type -> chorus.AddReplicationRequest
	1,  // 30: chorus.Policy.GetReplication:input_type -> chorus.ReplicationID
	4,  // 31: chorus.Policy.ListReplications:input_type -> chorus.ListReplicationsRequest
	1,  // 32: chorus.Policy.StreamReplication:input_type -> chorus.ReplicationID
	1,  // 33: chorus.Policy.PauseReplication:input_type -> chorus.ReplicationID
	1,  // 34: chorus.Policy.ResumeReplication:input_type -> chorus.ReplicationID
	1,  // 35: chorus.Policy.DeleteReplication:input_type -> chorus.ReplicationID
	11, // 36: chorus.Policy.SwitchWithZeroDowntime:input_type -> chorus.SwitchZeroDowntimeRequest
	12, // 37: chorus.Policy.SwitchWithDowntime:input_type -> chorus.SwitchDowntimeRequest
	1,  // 38: chorus.Policy.DeleteSwitch:input_type -> chorus.ReplicationID
	1,  // 39: chorus.Policy.GetSwitchStatus:input_type -> chorus.ReplicationID
	23, // 40: chorus.Policy.ReplicationDiff:input_type -> chorus.ReplicationDiffRequest
	1,  // 41: chorus.Policy.DeleteReplicationDiff:input_type -> chorus.ReplicationID
	15, // 42: chorus.Policy.ListRoutings:input_type -> chorus.RoutingsRequest
	19, // 43: chorus.Policy.AddRouting:input_type -> chorus.AddRoutingRequest
	20, // 44: chorus.Policy.DeleteRouting:input_type -> chorus.RoutingID
	20, // 45: chorus.Policy.BlockRouting:input_type -> chorus.RoutingID
	20, // 46: chorus.Policy.UnblockRouting:input_type -> chorus.RoutingID
	21, // 47: chorus.Policy.TestProxy:input_type -> chorus.TestProxyRequest
	8,  // 48: chorus.Policy.AvailableBuckets:output_type -> chorus.AvailableBucketsResponse
	29, // 49: chorus.Policy.AddReplication:output_type -> google.protobuf.Empty
	6,  // 50: chorus.Policy.GetReplication:output_type -> chorus.Replication
	5,  // 51: chorus.Policy.ListReplications:output_type -> chorus.ListReplicationsResponse
	6,  // 52: chorus.Policy.StreamReplication:output_type -> chorus.Replication
	29, // 53: chorus.Policy.PauseReplication:output_type -> google.protobuf.Empty
	29, // 54: chorus.Policy.ResumeReplication:output_type -> google.protobuf.Empty
	29, // 55: chorus.Policy.DeleteReplication:output_type -> google.protobuf.Empty
	29, // 56: chorus.Policy.SwitchWithZeroDowntime:output_type -> google.protobuf.Empty
	29, // 57: chorus.Policy.SwitchWithDowntime:output_type -> google.protobuf.Empty
	29, // 58: chorus.Policy.DeleteSwitch:output_type -> google.protobuf.Empty
	14, // 59: chorus.Policy.GetSwitchStatus:output_type -> chorus.ReplicationSwitch
	24, // 60: chorus.Policy.ReplicationDiff:output_type -> chorus.ReplicationDiffResponse
	29, // 61: chorus.Policy.DeleteReplicationDiff:output_type -> google.protobuf.Empty
	16, // 62: chorus.Policy.ListRoutings:output_type -> chorus.RoutingsResponse
	29, // 63: chorus.Policy.AddRouting:output_type -> google.protobuf.Empty
	29, // 64: chorus.Policy.DeleteRouting:output_type -> google.protobuf.Empty
	29, // 65: chorus.Policy.BlockRouting:output_type -> google.protobuf.Empty
	29, // 66: chorus.Policy.UnblockRouting:output_type -> google.protobuf.Empty
	22, // 67: chorus.Policy.TestProxy:output_type -> chorus.TestProxyResponse
	48, // [48:68] is the sub-list for method output_type
	28, // [28:48] is the sub-list for method input_type
	28, // [28:28] is the sub-list for extension type_name
	28, // [28:28] is the sub-list for extension extendee
	0,  // [0:28] is the sub-list for field type_name
}

func init() { file_chorus_policy_proto_init() }
func file_chorus_policy_proto_init() {
	if File_chorus_policy_proto != nil {
		return
	}
	file_chorus_policy_proto_msgTypes[0].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[2].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[5].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[10].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[11].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[12].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[13].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[14].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[18].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[19].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[24].OneofWrappers = []any{}
	file_chorus_policy_proto_msgTypes[25].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_chorus_policy_proto_rawDesc), len(file_chorus_policy_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   26,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_chorus_policy_proto_goTypes,
		DependencyIndexes: file_chorus_policy_proto_depIdxs,
		EnumInfos:         file_chorus_policy_proto_enumTypes,
		MessageInfos:      file_chorus_policy_proto_msgTypes,
	}.Build()
	File_chorus_policy_proto = out.File
	file_chorus_policy_proto_goTypes = nil
	file_chorus_policy_proto_depIdxs = nil
}
