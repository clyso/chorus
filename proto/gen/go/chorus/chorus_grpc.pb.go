// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: chorus/chorus.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Chorus_GetAppVersion_FullMethodName                    = "/chorus.Chorus/GetAppVersion"
	Chorus_GetStorages_FullMethodName                      = "/chorus.Chorus/GetStorages"
	Chorus_GetProxyCredentials_FullMethodName              = "/chorus.Chorus/GetProxyCredentials"
	Chorus_ListBucketsForReplication_FullMethodName        = "/chorus.Chorus/ListBucketsForReplication"
	Chorus_AddReplication_FullMethodName                   = "/chorus.Chorus/AddReplication"
	Chorus_ListReplications_FullMethodName                 = "/chorus.Chorus/ListReplications"
	Chorus_ListUserReplications_FullMethodName             = "/chorus.Chorus/ListUserReplications"
	Chorus_StreamBucketReplication_FullMethodName          = "/chorus.Chorus/StreamBucketReplication"
	Chorus_PauseReplication_FullMethodName                 = "/chorus.Chorus/PauseReplication"
	Chorus_ResumeReplication_FullMethodName                = "/chorus.Chorus/ResumeReplication"
	Chorus_DeleteReplication_FullMethodName                = "/chorus.Chorus/DeleteReplication"
	Chorus_DeleteUserReplication_FullMethodName            = "/chorus.Chorus/DeleteUserReplication"
	Chorus_SwitchBucketZeroDowntime_FullMethodName         = "/chorus.Chorus/SwitchBucketZeroDowntime"
	Chorus_SwitchBucket_FullMethodName                     = "/chorus.Chorus/SwitchBucket"
	Chorus_DeleteBucketSwitch_FullMethodName               = "/chorus.Chorus/DeleteBucketSwitch"
	Chorus_GetBucketSwitchStatus_FullMethodName            = "/chorus.Chorus/GetBucketSwitchStatus"
	Chorus_ListReplicationSwitches_FullMethodName          = "/chorus.Chorus/ListReplicationSwitches"
	Chorus_CompareBucket_FullMethodName                    = "/chorus.Chorus/CompareBucket"
	Chorus_GetAgents_FullMethodName                        = "/chorus.Chorus/GetAgents"
	Chorus_AddBucketReplication_FullMethodName             = "/chorus.Chorus/AddBucketReplication"
	Chorus_GetReplication_FullMethodName                   = "/chorus.Chorus/GetReplication"
	Chorus_StartConsistencyCheck_FullMethodName            = "/chorus.Chorus/StartConsistencyCheck"
	Chorus_ListConsistencyChecks_FullMethodName            = "/chorus.Chorus/ListConsistencyChecks"
	Chorus_GetConsistencyCheckReport_FullMethodName        = "/chorus.Chorus/GetConsistencyCheckReport"
	Chorus_GetConsistencyCheckReportEntries_FullMethodName = "/chorus.Chorus/GetConsistencyCheckReportEntries"
	Chorus_DeleteConsistencyCheckReport_FullMethodName     = "/chorus.Chorus/DeleteConsistencyCheckReport"
)

// ChorusClient is the client API for Chorus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChorusClient interface {
	// Get app version
	GetAppVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAppVersionResponse, error)
	// Lists configured storages with users
	GetStorages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetStoragesResponse, error)
	// Returns connection details for proxy s3 endpoint
	GetProxyCredentials(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetProxyCredentialsResponse, error)
	// Returns list of buckets to configure new replication.
	ListBucketsForReplication(ctx context.Context, in *ListBucketsForReplicationRequest, opts ...grpc.CallOption) (*ListBucketsForReplicationResponse, error)
	// Configures new replication for user or bucket(-s)
	AddReplication(ctx context.Context, in *AddReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Lists configured replications with statuses
	ListReplications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListReplicationsResponse, error)
	ListUserReplications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListUserReplicationsResponse, error)
	StreamBucketReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Replication], error)
	// Pauses given replication
	PauseReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Resumes given replication
	ResumeReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes given replication
	DeleteReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteUserReplication(ctx context.Context, in *DeleteUserReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Switch main<->follower for selected replication without downtime.
	// Switch will be started immediately. It will route all writes to new main bucket and resolve reads to bucket with the latest data without blocking. When all replication tasks will be processed, switch will be completed and all reads and writes will be routed to new bucket. Unlike switch with downtime, switch without downtime is not checking bucket contents on completion and cannot be aborted or reverted without risk of data loss.
	// Method will return error in following cases:
	//   - there is no existing bucket replication
	//   - there are multiple replications from the same main bucket to multiple followers
	//   - switch already exists. Zero downtime switch cannot be updated. Use DeleteBucketSwitch in this case.
	//   - replication is to different bucket name. Will be supported later.
	SwitchBucketZeroDowntime(ctx context.Context, in *SwitchBucketZeroDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Switch main<->follower for selected replication with downtime.
	// This method Can also be used to update existing switch if it has not started yet.
	// Workflow: stops write requests to bucket on chorus proxy until all replication tasks will be processed.
	// Then it checks if main and follower bucket contents are the same, unblocks writes, and routes all requests to follower bucket. If bucket contents are different, switch will be aborted and writes will be unblocked. Downtime Switch can be aborted or reverted without risk of data loss.
	// Method will return error in following cases:
	//   - there is no existing bucket replication
	//   - there are multiple replications from the same main bucket to multiple followers
	//   - switch is in progress - aka writes already blocked. Use DeleteBucketSwitch in this case.
	//   - switch is successfully finished
	//   - replication is to different bucket name. Will be supported later.
	SwitchBucket(ctx context.Context, in *SwitchBucketRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes Switch with following implications:
	// !!!Use with caution for ZeroDowntime switch.
	//   - If switch was in not_started, error, or skipped state, it will not be attempted anymore.
	//     proxy will route all requests to old bucket.
	//   - If switch was in progress, it will be aborted. For downtime switch, bucket block will be removed
	//     proxy will route all requests to old bucket, no data will be lost.
	//     !!!For ZeroDowntime switch, routing will be reverted back to old bucket.
	//     Old and new buckets may end up in inconsistent state because all object writes happened
	//     since start of no_downtime migration were routed only to new bucket.
	//   - If switch was done. Only switch metadata will be removed, replication or routing will not be affected.
	DeleteBucketSwitch(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns Switch status
	GetBucketSwitchStatus(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*GetBucketSwitchStatusResponse, error)
	// returns list of all switches
	ListReplicationSwitches(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListSwitchResponse, error)
	// Compares contents of given bucket in given storages
	CompareBucket(ctx context.Context, in *CompareBucketRequest, opts ...grpc.CallOption) (*CompareBucketResponse, error)
	GetAgents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAgentsResponse, error)
	AddBucketReplication(ctx context.Context, in *AddBucketReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*Replication, error)
	StartConsistencyCheck(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListConsistencyChecks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListConsistencyChecksResponse, error)
	GetConsistencyCheckReport(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*GetConsistencyCheckReportResponse, error)
	GetConsistencyCheckReportEntries(ctx context.Context, in *GetConsistencyCheckReportEntriesRequest, opts ...grpc.CallOption) (*GetConsistencyCheckReportEntriesResponse, error)
	DeleteConsistencyCheckReport(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type chorusClient struct {
	cc grpc.ClientConnInterface
}

func NewChorusClient(cc grpc.ClientConnInterface) ChorusClient {
	return &chorusClient{cc}
}

func (c *chorusClient) GetAppVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAppVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAppVersionResponse)
	err := c.cc.Invoke(ctx, Chorus_GetAppVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetStorages(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetStoragesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStoragesResponse)
	err := c.cc.Invoke(ctx, Chorus_GetStorages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetProxyCredentials(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetProxyCredentialsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProxyCredentialsResponse)
	err := c.cc.Invoke(ctx, Chorus_GetProxyCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ListBucketsForReplication(ctx context.Context, in *ListBucketsForReplicationRequest, opts ...grpc.CallOption) (*ListBucketsForReplicationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBucketsForReplicationResponse)
	err := c.cc.Invoke(ctx, Chorus_ListBucketsForReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) AddReplication(ctx context.Context, in *AddReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_AddReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ListReplications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListReplicationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReplicationsResponse)
	err := c.cc.Invoke(ctx, Chorus_ListReplications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ListUserReplications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListUserReplicationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserReplicationsResponse)
	err := c.cc.Invoke(ctx, Chorus_ListUserReplications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) StreamBucketReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Replication], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Chorus_ServiceDesc.Streams[0], Chorus_StreamBucketReplication_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReplicationRequest, Replication]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Chorus_StreamBucketReplicationClient = grpc.ServerStreamingClient[Replication]

func (c *chorusClient) PauseReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_PauseReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ResumeReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_ResumeReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) DeleteReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_DeleteReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) DeleteUserReplication(ctx context.Context, in *DeleteUserReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_DeleteUserReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) SwitchBucketZeroDowntime(ctx context.Context, in *SwitchBucketZeroDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_SwitchBucketZeroDowntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) SwitchBucket(ctx context.Context, in *SwitchBucketRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_SwitchBucket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) DeleteBucketSwitch(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_DeleteBucketSwitch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetBucketSwitchStatus(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*GetBucketSwitchStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBucketSwitchStatusResponse)
	err := c.cc.Invoke(ctx, Chorus_GetBucketSwitchStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ListReplicationSwitches(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListSwitchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSwitchResponse)
	err := c.cc.Invoke(ctx, Chorus_ListReplicationSwitches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) CompareBucket(ctx context.Context, in *CompareBucketRequest, opts ...grpc.CallOption) (*CompareBucketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompareBucketResponse)
	err := c.cc.Invoke(ctx, Chorus_CompareBucket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetAgents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentsResponse)
	err := c.cc.Invoke(ctx, Chorus_GetAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) AddBucketReplication(ctx context.Context, in *AddBucketReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_AddBucketReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetReplication(ctx context.Context, in *ReplicationRequest, opts ...grpc.CallOption) (*Replication, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Replication)
	err := c.cc.Invoke(ctx, Chorus_GetReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) StartConsistencyCheck(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_StartConsistencyCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) ListConsistencyChecks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListConsistencyChecksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsistencyChecksResponse)
	err := c.cc.Invoke(ctx, Chorus_ListConsistencyChecks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetConsistencyCheckReport(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*GetConsistencyCheckReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsistencyCheckReportResponse)
	err := c.cc.Invoke(ctx, Chorus_GetConsistencyCheckReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) GetConsistencyCheckReportEntries(ctx context.Context, in *GetConsistencyCheckReportEntriesRequest, opts ...grpc.CallOption) (*GetConsistencyCheckReportEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsistencyCheckReportEntriesResponse)
	err := c.cc.Invoke(ctx, Chorus_GetConsistencyCheckReportEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chorusClient) DeleteConsistencyCheckReport(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Chorus_DeleteConsistencyCheckReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChorusServer is the server API for Chorus service.
// All implementations should embed UnimplementedChorusServer
// for forward compatibility.
type ChorusServer interface {
	// Get app version
	GetAppVersion(context.Context, *emptypb.Empty) (*GetAppVersionResponse, error)
	// Lists configured storages with users
	GetStorages(context.Context, *emptypb.Empty) (*GetStoragesResponse, error)
	// Returns connection details for proxy s3 endpoint
	GetProxyCredentials(context.Context, *emptypb.Empty) (*GetProxyCredentialsResponse, error)
	// Returns list of buckets to configure new replication.
	ListBucketsForReplication(context.Context, *ListBucketsForReplicationRequest) (*ListBucketsForReplicationResponse, error)
	// Configures new replication for user or bucket(-s)
	AddReplication(context.Context, *AddReplicationRequest) (*emptypb.Empty, error)
	// Lists configured replications with statuses
	ListReplications(context.Context, *emptypb.Empty) (*ListReplicationsResponse, error)
	ListUserReplications(context.Context, *emptypb.Empty) (*ListUserReplicationsResponse, error)
	StreamBucketReplication(*ReplicationRequest, grpc.ServerStreamingServer[Replication]) error
	// Pauses given replication
	PauseReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error)
	// Resumes given replication
	ResumeReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error)
	// Deletes given replication
	DeleteReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error)
	DeleteUserReplication(context.Context, *DeleteUserReplicationRequest) (*emptypb.Empty, error)
	// Switch main<->follower for selected replication without downtime.
	// Switch will be started immediately. It will route all writes to new main bucket and resolve reads to bucket with the latest data without blocking. When all replication tasks will be processed, switch will be completed and all reads and writes will be routed to new bucket. Unlike switch with downtime, switch without downtime is not checking bucket contents on completion and cannot be aborted or reverted without risk of data loss.
	// Method will return error in following cases:
	//   - there is no existing bucket replication
	//   - there are multiple replications from the same main bucket to multiple followers
	//   - switch already exists. Zero downtime switch cannot be updated. Use DeleteBucketSwitch in this case.
	//   - replication is to different bucket name. Will be supported later.
	SwitchBucketZeroDowntime(context.Context, *SwitchBucketZeroDowntimeRequest) (*emptypb.Empty, error)
	// Switch main<->follower for selected replication with downtime.
	// This method Can also be used to update existing switch if it has not started yet.
	// Workflow: stops write requests to bucket on chorus proxy until all replication tasks will be processed.
	// Then it checks if main and follower bucket contents are the same, unblocks writes, and routes all requests to follower bucket. If bucket contents are different, switch will be aborted and writes will be unblocked. Downtime Switch can be aborted or reverted without risk of data loss.
	// Method will return error in following cases:
	//   - there is no existing bucket replication
	//   - there are multiple replications from the same main bucket to multiple followers
	//   - switch is in progress - aka writes already blocked. Use DeleteBucketSwitch in this case.
	//   - switch is successfully finished
	//   - replication is to different bucket name. Will be supported later.
	SwitchBucket(context.Context, *SwitchBucketRequest) (*emptypb.Empty, error)
	// Deletes Switch with following implications:
	// !!!Use with caution for ZeroDowntime switch.
	//   - If switch was in not_started, error, or skipped state, it will not be attempted anymore.
	//     proxy will route all requests to old bucket.
	//   - If switch was in progress, it will be aborted. For downtime switch, bucket block will be removed
	//     proxy will route all requests to old bucket, no data will be lost.
	//     !!!For ZeroDowntime switch, routing will be reverted back to old bucket.
	//     Old and new buckets may end up in inconsistent state because all object writes happened
	//     since start of no_downtime migration were routed only to new bucket.
	//   - If switch was done. Only switch metadata will be removed, replication or routing will not be affected.
	DeleteBucketSwitch(context.Context, *ReplicationRequest) (*emptypb.Empty, error)
	// Returns Switch status
	GetBucketSwitchStatus(context.Context, *ReplicationRequest) (*GetBucketSwitchStatusResponse, error)
	// returns list of all switches
	ListReplicationSwitches(context.Context, *emptypb.Empty) (*ListSwitchResponse, error)
	// Compares contents of given bucket in given storages
	CompareBucket(context.Context, *CompareBucketRequest) (*CompareBucketResponse, error)
	GetAgents(context.Context, *emptypb.Empty) (*GetAgentsResponse, error)
	AddBucketReplication(context.Context, *AddBucketReplicationRequest) (*emptypb.Empty, error)
	GetReplication(context.Context, *ReplicationRequest) (*Replication, error)
	StartConsistencyCheck(context.Context, *ConsistencyCheckRequest) (*emptypb.Empty, error)
	ListConsistencyChecks(context.Context, *emptypb.Empty) (*ListConsistencyChecksResponse, error)
	GetConsistencyCheckReport(context.Context, *ConsistencyCheckRequest) (*GetConsistencyCheckReportResponse, error)
	GetConsistencyCheckReportEntries(context.Context, *GetConsistencyCheckReportEntriesRequest) (*GetConsistencyCheckReportEntriesResponse, error)
	DeleteConsistencyCheckReport(context.Context, *ConsistencyCheckRequest) (*emptypb.Empty, error)
}

// UnimplementedChorusServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChorusServer struct{}

func (UnimplementedChorusServer) GetAppVersion(context.Context, *emptypb.Empty) (*GetAppVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppVersion not implemented")
}
func (UnimplementedChorusServer) GetStorages(context.Context, *emptypb.Empty) (*GetStoragesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorages not implemented")
}
func (UnimplementedChorusServer) GetProxyCredentials(context.Context, *emptypb.Empty) (*GetProxyCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProxyCredentials not implemented")
}
func (UnimplementedChorusServer) ListBucketsForReplication(context.Context, *ListBucketsForReplicationRequest) (*ListBucketsForReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBucketsForReplication not implemented")
}
func (UnimplementedChorusServer) AddReplication(context.Context, *AddReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplication not implemented")
}
func (UnimplementedChorusServer) ListReplications(context.Context, *emptypb.Empty) (*ListReplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReplications not implemented")
}
func (UnimplementedChorusServer) ListUserReplications(context.Context, *emptypb.Empty) (*ListUserReplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserReplications not implemented")
}
func (UnimplementedChorusServer) StreamBucketReplication(*ReplicationRequest, grpc.ServerStreamingServer[Replication]) error {
	return status.Errorf(codes.Unimplemented, "method StreamBucketReplication not implemented")
}
func (UnimplementedChorusServer) PauseReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseReplication not implemented")
}
func (UnimplementedChorusServer) ResumeReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeReplication not implemented")
}
func (UnimplementedChorusServer) DeleteReplication(context.Context, *ReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReplication not implemented")
}
func (UnimplementedChorusServer) DeleteUserReplication(context.Context, *DeleteUserReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserReplication not implemented")
}
func (UnimplementedChorusServer) SwitchBucketZeroDowntime(context.Context, *SwitchBucketZeroDowntimeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchBucketZeroDowntime not implemented")
}
func (UnimplementedChorusServer) SwitchBucket(context.Context, *SwitchBucketRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchBucket not implemented")
}
func (UnimplementedChorusServer) DeleteBucketSwitch(context.Context, *ReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBucketSwitch not implemented")
}
func (UnimplementedChorusServer) GetBucketSwitchStatus(context.Context, *ReplicationRequest) (*GetBucketSwitchStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBucketSwitchStatus not implemented")
}
func (UnimplementedChorusServer) ListReplicationSwitches(context.Context, *emptypb.Empty) (*ListSwitchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReplicationSwitches not implemented")
}
func (UnimplementedChorusServer) CompareBucket(context.Context, *CompareBucketRequest) (*CompareBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompareBucket not implemented")
}
func (UnimplementedChorusServer) GetAgents(context.Context, *emptypb.Empty) (*GetAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgents not implemented")
}
func (UnimplementedChorusServer) AddBucketReplication(context.Context, *AddBucketReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBucketReplication not implemented")
}
func (UnimplementedChorusServer) GetReplication(context.Context, *ReplicationRequest) (*Replication, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReplication not implemented")
}
func (UnimplementedChorusServer) StartConsistencyCheck(context.Context, *ConsistencyCheckRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartConsistencyCheck not implemented")
}
func (UnimplementedChorusServer) ListConsistencyChecks(context.Context, *emptypb.Empty) (*ListConsistencyChecksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConsistencyChecks not implemented")
}
func (UnimplementedChorusServer) GetConsistencyCheckReport(context.Context, *ConsistencyCheckRequest) (*GetConsistencyCheckReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsistencyCheckReport not implemented")
}
func (UnimplementedChorusServer) GetConsistencyCheckReportEntries(context.Context, *GetConsistencyCheckReportEntriesRequest) (*GetConsistencyCheckReportEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsistencyCheckReportEntries not implemented")
}
func (UnimplementedChorusServer) DeleteConsistencyCheckReport(context.Context, *ConsistencyCheckRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConsistencyCheckReport not implemented")
}
func (UnimplementedChorusServer) testEmbeddedByValue() {}

// UnsafeChorusServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChorusServer will
// result in compilation errors.
type UnsafeChorusServer interface {
	mustEmbedUnimplementedChorusServer()
}

func RegisterChorusServer(s grpc.ServiceRegistrar, srv ChorusServer) {
	// If the following call pancis, it indicates UnimplementedChorusServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Chorus_ServiceDesc, srv)
}

func _Chorus_GetAppVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetAppVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetAppVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetAppVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetStorages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetStorages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetStorages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetStorages(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetProxyCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetProxyCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetProxyCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetProxyCredentials(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ListBucketsForReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBucketsForReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ListBucketsForReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ListBucketsForReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ListBucketsForReplication(ctx, req.(*ListBucketsForReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_AddReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).AddReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_AddReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).AddReplication(ctx, req.(*AddReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ListReplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ListReplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ListReplications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ListReplications(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ListUserReplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ListUserReplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ListUserReplications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ListUserReplications(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_StreamBucketReplication_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplicationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChorusServer).StreamBucketReplication(m, &grpc.GenericServerStream[ReplicationRequest, Replication]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Chorus_StreamBucketReplicationServer = grpc.ServerStreamingServer[Replication]

func _Chorus_PauseReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).PauseReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_PauseReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).PauseReplication(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ResumeReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ResumeReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ResumeReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ResumeReplication(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_DeleteReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).DeleteReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_DeleteReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).DeleteReplication(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_DeleteUserReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).DeleteUserReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_DeleteUserReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).DeleteUserReplication(ctx, req.(*DeleteUserReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_SwitchBucketZeroDowntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchBucketZeroDowntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).SwitchBucketZeroDowntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_SwitchBucketZeroDowntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).SwitchBucketZeroDowntime(ctx, req.(*SwitchBucketZeroDowntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_SwitchBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).SwitchBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_SwitchBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).SwitchBucket(ctx, req.(*SwitchBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_DeleteBucketSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).DeleteBucketSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_DeleteBucketSwitch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).DeleteBucketSwitch(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetBucketSwitchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetBucketSwitchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetBucketSwitchStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetBucketSwitchStatus(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ListReplicationSwitches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ListReplicationSwitches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ListReplicationSwitches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ListReplicationSwitches(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_CompareBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).CompareBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_CompareBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).CompareBucket(ctx, req.(*CompareBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetAgents(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_AddBucketReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBucketReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).AddBucketReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_AddBucketReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).AddBucketReplication(ctx, req.(*AddBucketReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetReplication(ctx, req.(*ReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_StartConsistencyCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsistencyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).StartConsistencyCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_StartConsistencyCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).StartConsistencyCheck(ctx, req.(*ConsistencyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_ListConsistencyChecks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).ListConsistencyChecks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_ListConsistencyChecks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).ListConsistencyChecks(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetConsistencyCheckReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsistencyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetConsistencyCheckReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetConsistencyCheckReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetConsistencyCheckReport(ctx, req.(*ConsistencyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_GetConsistencyCheckReportEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsistencyCheckReportEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).GetConsistencyCheckReportEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_GetConsistencyCheckReportEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).GetConsistencyCheckReportEntries(ctx, req.(*GetConsistencyCheckReportEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chorus_DeleteConsistencyCheckReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsistencyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChorusServer).DeleteConsistencyCheckReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Chorus_DeleteConsistencyCheckReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChorusServer).DeleteConsistencyCheckReport(ctx, req.(*ConsistencyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Chorus_ServiceDesc is the grpc.ServiceDesc for Chorus service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Chorus_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chorus.Chorus",
	HandlerType: (*ChorusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAppVersion",
			Handler:    _Chorus_GetAppVersion_Handler,
		},
		{
			MethodName: "GetStorages",
			Handler:    _Chorus_GetStorages_Handler,
		},
		{
			MethodName: "GetProxyCredentials",
			Handler:    _Chorus_GetProxyCredentials_Handler,
		},
		{
			MethodName: "ListBucketsForReplication",
			Handler:    _Chorus_ListBucketsForReplication_Handler,
		},
		{
			MethodName: "AddReplication",
			Handler:    _Chorus_AddReplication_Handler,
		},
		{
			MethodName: "ListReplications",
			Handler:    _Chorus_ListReplications_Handler,
		},
		{
			MethodName: "ListUserReplications",
			Handler:    _Chorus_ListUserReplications_Handler,
		},
		{
			MethodName: "PauseReplication",
			Handler:    _Chorus_PauseReplication_Handler,
		},
		{
			MethodName: "ResumeReplication",
			Handler:    _Chorus_ResumeReplication_Handler,
		},
		{
			MethodName: "DeleteReplication",
			Handler:    _Chorus_DeleteReplication_Handler,
		},
		{
			MethodName: "DeleteUserReplication",
			Handler:    _Chorus_DeleteUserReplication_Handler,
		},
		{
			MethodName: "SwitchBucketZeroDowntime",
			Handler:    _Chorus_SwitchBucketZeroDowntime_Handler,
		},
		{
			MethodName: "SwitchBucket",
			Handler:    _Chorus_SwitchBucket_Handler,
		},
		{
			MethodName: "DeleteBucketSwitch",
			Handler:    _Chorus_DeleteBucketSwitch_Handler,
		},
		{
			MethodName: "GetBucketSwitchStatus",
			Handler:    _Chorus_GetBucketSwitchStatus_Handler,
		},
		{
			MethodName: "ListReplicationSwitches",
			Handler:    _Chorus_ListReplicationSwitches_Handler,
		},
		{
			MethodName: "CompareBucket",
			Handler:    _Chorus_CompareBucket_Handler,
		},
		{
			MethodName: "GetAgents",
			Handler:    _Chorus_GetAgents_Handler,
		},
		{
			MethodName: "AddBucketReplication",
			Handler:    _Chorus_AddBucketReplication_Handler,
		},
		{
			MethodName: "GetReplication",
			Handler:    _Chorus_GetReplication_Handler,
		},
		{
			MethodName: "StartConsistencyCheck",
			Handler:    _Chorus_StartConsistencyCheck_Handler,
		},
		{
			MethodName: "ListConsistencyChecks",
			Handler:    _Chorus_ListConsistencyChecks_Handler,
		},
		{
			MethodName: "GetConsistencyCheckReport",
			Handler:    _Chorus_GetConsistencyCheckReport_Handler,
		},
		{
			MethodName: "GetConsistencyCheckReportEntries",
			Handler:    _Chorus_GetConsistencyCheckReportEntries_Handler,
		},
		{
			MethodName: "DeleteConsistencyCheckReport",
			Handler:    _Chorus_DeleteConsistencyCheckReport_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamBucketReplication",
			Handler:       _Chorus_StreamBucketReplication_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "chorus/chorus.proto",
}
