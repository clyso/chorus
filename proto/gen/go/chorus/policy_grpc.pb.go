// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: chorus/policy.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Policy_AvailableBuckets_FullMethodName       = "/chorus.Policy/AvailableBuckets"
	Policy_AddReplication_FullMethodName         = "/chorus.Policy/AddReplication"
	Policy_GetReplication_FullMethodName         = "/chorus.Policy/GetReplication"
	Policy_ListReplications_FullMethodName       = "/chorus.Policy/ListReplications"
	Policy_StreamReplication_FullMethodName      = "/chorus.Policy/StreamReplication"
	Policy_PauseReplication_FullMethodName       = "/chorus.Policy/PauseReplication"
	Policy_ResumeReplication_FullMethodName      = "/chorus.Policy/ResumeReplication"
	Policy_DeleteReplication_FullMethodName      = "/chorus.Policy/DeleteReplication"
	Policy_SwitchWithZeroDowntime_FullMethodName = "/chorus.Policy/SwitchWithZeroDowntime"
	Policy_SwitchWithDowntime_FullMethodName     = "/chorus.Policy/SwitchWithDowntime"
	Policy_DeleteSwitch_FullMethodName           = "/chorus.Policy/DeleteSwitch"
	Policy_GetSwitchStatus_FullMethodName        = "/chorus.Policy/GetSwitchStatus"
	Policy_CompareBucket_FullMethodName          = "/chorus.Policy/CompareBucket"
	Policy_ListRoutings_FullMethodName           = "/chorus.Policy/ListRoutings"
	Policy_AddRouting_FullMethodName             = "/chorus.Policy/AddRouting"
	Policy_DeleteRouting_FullMethodName          = "/chorus.Policy/DeleteRouting"
	Policy_BlockRouting_FullMethodName           = "/chorus.Policy/BlockRouting"
	Policy_UnblockRouting_FullMethodName         = "/chorus.Policy/UnblockRouting"
	Policy_TestProxy_FullMethodName              = "/chorus.Policy/TestProxy"
)

// PolicyClient is the client API for Policy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Manages chorus routing/replication policies
type PolicyClient interface {
	// Returns list of buckets available for replication.
	AvailableBuckets(ctx context.Context, in *AvailableBucketsRequest, opts ...grpc.CallOption) (*AvailableBucketsResponse, error)
	// Configures new bucket-level or user-level replication.
	AddReplication(ctx context.Context, in *AddReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns replication info by ID.
	GetReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*Replication, error)
	// Lists configured replications info.
	ListReplications(ctx context.Context, in *ListReplicationsRequest, opts ...grpc.CallOption) (*ListReplicationsResponse, error)
	// Subscribes to replication updates stream.
	StreamReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Replication], error)
	// Pauses given replication
	PauseReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Resumes given replication
	ResumeReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes given replication
	DeleteReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Switches source<->destination replication targets without downtime.
	// Zero-downtime switch will take effect immediately on chorus proxy:
	// - all writes will be now routed to replication destination
	// - all reads will be routed to target with latest data
	// When all replication tasks will be processed, switch will be completed and
	// all reads and writes will be routed to destination target only.
	//
	// Unlike switch with downtime, zero-downtime switch is not checking bucket
	// contents on completion and cannot be aborted or reverted without risk of
	// data loss.
	// Requirements for zero-downtime switch:
	//   - replication must exist
	//   - replication must be proxy-based (agent replication is not supported)
	//   - for bucket-level replication, from/to bucket names must be the same
	//   - no existing switch must exist for given replication. Zero downtime
	//     switch cannot be updated. Use DeleteBucketSwitch in this case.
	SwitchWithZeroDowntime(ctx context.Context, in *SwitchZeroDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Schedules downtime window to switch source<->destination replication
	// targets. See SwitchDowntimeOpts for downtime scheduling options.
	// Can be edited if downtime window has not started yet.
	//
	// During downtime window all requests to replication target are blocked on
	// chorus proxy. When all replication tasks are processed, chorus can perform
	// optional data equality check and complete the switch. On completion, proxy
	// unblocks requests to target and routes all requests to destination target.
	//
	// Unlike zero-downtime switch, downtime switch can perform optional data
	// equality check and rollback to source target without data loss.
	// Requirements:
	//   - replication must exist
	//   - replication must be proxy-based (agent replication is not supported)
	//   - for bucket-level replication, from/to bucket names must be the same
	//   - switch is not started. Use DeleteBucketSwitch in this case.
	SwitchWithDowntime(ctx context.Context, in *SwitchDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Deletes Switch with following implications:
	// !!!Use with caution for ZeroDowntime switch.
	//
	// - [OK] If switch was in not_started, error, or skipped state, it will not
	// be attempted anymore. Routing will not be affected.
	// - If switch was in_progress, it will be aborted:
	//   - [OK] For downtime switch, block will be removed and proxy will
	//     route all requests to source target, no data will be lost.
	//   - [WARN] For ZeroDowntime switch, routing will be reverted back to
	//     source target. Meaning that targets may end up in inconsistent state
	//     because some writes were already routed to destination target.
	//
	// - [OK] If switch was done. Only switch metadata will be removed,
	// replication or routing will not be affected.
	DeleteSwitch(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns Switch status
	GetSwitchStatus(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*ReplicationSwitch, error)
	// Deprecated: Do not use.
	// Compares contents of given bucket in given storages
	CompareBucket(ctx context.Context, in *CompareBucketRequest, opts ...grpc.CallOption) (*CompareBucketResponse, error)
	// Returns configured routing policies for chorus proxy.
	ListRoutings(ctx context.Context, in *RoutingsRequest, opts ...grpc.CallOption) (*RoutingsResponse, error)
	// Overrides routing destination for given user or user's bucket.
	AddRouting(ctx context.Context, in *AddRoutingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Removes user or bucket routing override.
	DeleteRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Blocks requests on proxy for given user or user's bucket.
	BlockRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Removes block on requests on proxy for given user or user's bucket.
	UnblockRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Returns configured routing and replication for given storage request to
	// proxy. Emulates proxy behaviour for given user and bucket.
	TestProxy(ctx context.Context, in *TestProxyRequest, opts ...grpc.CallOption) (*TestProxyResponse, error)
}

type policyClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyClient(cc grpc.ClientConnInterface) PolicyClient {
	return &policyClient{cc}
}

func (c *policyClient) AvailableBuckets(ctx context.Context, in *AvailableBucketsRequest, opts ...grpc.CallOption) (*AvailableBucketsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableBucketsResponse)
	err := c.cc.Invoke(ctx, Policy_AvailableBuckets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) AddReplication(ctx context.Context, in *AddReplicationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_AddReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) GetReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*Replication, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Replication)
	err := c.cc.Invoke(ctx, Policy_GetReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) ListReplications(ctx context.Context, in *ListReplicationsRequest, opts ...grpc.CallOption) (*ListReplicationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReplicationsResponse)
	err := c.cc.Invoke(ctx, Policy_ListReplications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) StreamReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Replication], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Policy_ServiceDesc.Streams[0], Policy_StreamReplication_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReplicationID, Replication]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Policy_StreamReplicationClient = grpc.ServerStreamingClient[Replication]

func (c *policyClient) PauseReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_PauseReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) ResumeReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_ResumeReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) DeleteReplication(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_DeleteReplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) SwitchWithZeroDowntime(ctx context.Context, in *SwitchZeroDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_SwitchWithZeroDowntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) SwitchWithDowntime(ctx context.Context, in *SwitchDowntimeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_SwitchWithDowntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) DeleteSwitch(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_DeleteSwitch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) GetSwitchStatus(ctx context.Context, in *ReplicationID, opts ...grpc.CallOption) (*ReplicationSwitch, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplicationSwitch)
	err := c.cc.Invoke(ctx, Policy_GetSwitchStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *policyClient) CompareBucket(ctx context.Context, in *CompareBucketRequest, opts ...grpc.CallOption) (*CompareBucketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompareBucketResponse)
	err := c.cc.Invoke(ctx, Policy_CompareBucket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) ListRoutings(ctx context.Context, in *RoutingsRequest, opts ...grpc.CallOption) (*RoutingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutingsResponse)
	err := c.cc.Invoke(ctx, Policy_ListRoutings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) AddRouting(ctx context.Context, in *AddRoutingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_AddRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) DeleteRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_DeleteRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) BlockRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_BlockRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) UnblockRouting(ctx context.Context, in *RoutingID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Policy_UnblockRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyClient) TestProxy(ctx context.Context, in *TestProxyRequest, opts ...grpc.CallOption) (*TestProxyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestProxyResponse)
	err := c.cc.Invoke(ctx, Policy_TestProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyServer is the server API for Policy service.
// All implementations should embed UnimplementedPolicyServer
// for forward compatibility.
//
// Manages chorus routing/replication policies
type PolicyServer interface {
	// Returns list of buckets available for replication.
	AvailableBuckets(context.Context, *AvailableBucketsRequest) (*AvailableBucketsResponse, error)
	// Configures new bucket-level or user-level replication.
	AddReplication(context.Context, *AddReplicationRequest) (*emptypb.Empty, error)
	// Returns replication info by ID.
	GetReplication(context.Context, *ReplicationID) (*Replication, error)
	// Lists configured replications info.
	ListReplications(context.Context, *ListReplicationsRequest) (*ListReplicationsResponse, error)
	// Subscribes to replication updates stream.
	StreamReplication(*ReplicationID, grpc.ServerStreamingServer[Replication]) error
	// Pauses given replication
	PauseReplication(context.Context, *ReplicationID) (*emptypb.Empty, error)
	// Resumes given replication
	ResumeReplication(context.Context, *ReplicationID) (*emptypb.Empty, error)
	// Deletes given replication
	DeleteReplication(context.Context, *ReplicationID) (*emptypb.Empty, error)
	// Switches source<->destination replication targets without downtime.
	// Zero-downtime switch will take effect immediately on chorus proxy:
	// - all writes will be now routed to replication destination
	// - all reads will be routed to target with latest data
	// When all replication tasks will be processed, switch will be completed and
	// all reads and writes will be routed to destination target only.
	//
	// Unlike switch with downtime, zero-downtime switch is not checking bucket
	// contents on completion and cannot be aborted or reverted without risk of
	// data loss.
	// Requirements for zero-downtime switch:
	//   - replication must exist
	//   - replication must be proxy-based (agent replication is not supported)
	//   - for bucket-level replication, from/to bucket names must be the same
	//   - no existing switch must exist for given replication. Zero downtime
	//     switch cannot be updated. Use DeleteBucketSwitch in this case.
	SwitchWithZeroDowntime(context.Context, *SwitchZeroDowntimeRequest) (*emptypb.Empty, error)
	// Schedules downtime window to switch source<->destination replication
	// targets. See SwitchDowntimeOpts for downtime scheduling options.
	// Can be edited if downtime window has not started yet.
	//
	// During downtime window all requests to replication target are blocked on
	// chorus proxy. When all replication tasks are processed, chorus can perform
	// optional data equality check and complete the switch. On completion, proxy
	// unblocks requests to target and routes all requests to destination target.
	//
	// Unlike zero-downtime switch, downtime switch can perform optional data
	// equality check and rollback to source target without data loss.
	// Requirements:
	//   - replication must exist
	//   - replication must be proxy-based (agent replication is not supported)
	//   - for bucket-level replication, from/to bucket names must be the same
	//   - switch is not started. Use DeleteBucketSwitch in this case.
	SwitchWithDowntime(context.Context, *SwitchDowntimeRequest) (*emptypb.Empty, error)
	// Deletes Switch with following implications:
	// !!!Use with caution for ZeroDowntime switch.
	//
	// - [OK] If switch was in not_started, error, or skipped state, it will not
	// be attempted anymore. Routing will not be affected.
	// - If switch was in_progress, it will be aborted:
	//   - [OK] For downtime switch, block will be removed and proxy will
	//     route all requests to source target, no data will be lost.
	//   - [WARN] For ZeroDowntime switch, routing will be reverted back to
	//     source target. Meaning that targets may end up in inconsistent state
	//     because some writes were already routed to destination target.
	//
	// - [OK] If switch was done. Only switch metadata will be removed,
	// replication or routing will not be affected.
	DeleteSwitch(context.Context, *ReplicationID) (*emptypb.Empty, error)
	// Returns Switch status
	GetSwitchStatus(context.Context, *ReplicationID) (*ReplicationSwitch, error)
	// Deprecated: Do not use.
	// Compares contents of given bucket in given storages
	CompareBucket(context.Context, *CompareBucketRequest) (*CompareBucketResponse, error)
	// Returns configured routing policies for chorus proxy.
	ListRoutings(context.Context, *RoutingsRequest) (*RoutingsResponse, error)
	// Overrides routing destination for given user or user's bucket.
	AddRouting(context.Context, *AddRoutingRequest) (*emptypb.Empty, error)
	// Removes user or bucket routing override.
	DeleteRouting(context.Context, *RoutingID) (*emptypb.Empty, error)
	// Blocks requests on proxy for given user or user's bucket.
	BlockRouting(context.Context, *RoutingID) (*emptypb.Empty, error)
	// Removes block on requests on proxy for given user or user's bucket.
	UnblockRouting(context.Context, *RoutingID) (*emptypb.Empty, error)
	// Returns configured routing and replication for given storage request to
	// proxy. Emulates proxy behaviour for given user and bucket.
	TestProxy(context.Context, *TestProxyRequest) (*TestProxyResponse, error)
}

// UnimplementedPolicyServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPolicyServer struct{}

func (UnimplementedPolicyServer) AvailableBuckets(context.Context, *AvailableBucketsRequest) (*AvailableBucketsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableBuckets not implemented")
}
func (UnimplementedPolicyServer) AddReplication(context.Context, *AddReplicationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplication not implemented")
}
func (UnimplementedPolicyServer) GetReplication(context.Context, *ReplicationID) (*Replication, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReplication not implemented")
}
func (UnimplementedPolicyServer) ListReplications(context.Context, *ListReplicationsRequest) (*ListReplicationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReplications not implemented")
}
func (UnimplementedPolicyServer) StreamReplication(*ReplicationID, grpc.ServerStreamingServer[Replication]) error {
	return status.Errorf(codes.Unimplemented, "method StreamReplication not implemented")
}
func (UnimplementedPolicyServer) PauseReplication(context.Context, *ReplicationID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseReplication not implemented")
}
func (UnimplementedPolicyServer) ResumeReplication(context.Context, *ReplicationID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeReplication not implemented")
}
func (UnimplementedPolicyServer) DeleteReplication(context.Context, *ReplicationID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReplication not implemented")
}
func (UnimplementedPolicyServer) SwitchWithZeroDowntime(context.Context, *SwitchZeroDowntimeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchWithZeroDowntime not implemented")
}
func (UnimplementedPolicyServer) SwitchWithDowntime(context.Context, *SwitchDowntimeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchWithDowntime not implemented")
}
func (UnimplementedPolicyServer) DeleteSwitch(context.Context, *ReplicationID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSwitch not implemented")
}
func (UnimplementedPolicyServer) GetSwitchStatus(context.Context, *ReplicationID) (*ReplicationSwitch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSwitchStatus not implemented")
}
func (UnimplementedPolicyServer) CompareBucket(context.Context, *CompareBucketRequest) (*CompareBucketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompareBucket not implemented")
}
func (UnimplementedPolicyServer) ListRoutings(context.Context, *RoutingsRequest) (*RoutingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoutings not implemented")
}
func (UnimplementedPolicyServer) AddRouting(context.Context, *AddRoutingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRouting not implemented")
}
func (UnimplementedPolicyServer) DeleteRouting(context.Context, *RoutingID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRouting not implemented")
}
func (UnimplementedPolicyServer) BlockRouting(context.Context, *RoutingID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockRouting not implemented")
}
func (UnimplementedPolicyServer) UnblockRouting(context.Context, *RoutingID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnblockRouting not implemented")
}
func (UnimplementedPolicyServer) TestProxy(context.Context, *TestProxyRequest) (*TestProxyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestProxy not implemented")
}
func (UnimplementedPolicyServer) testEmbeddedByValue() {}

// UnsafePolicyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PolicyServer will
// result in compilation errors.
type UnsafePolicyServer interface {
	mustEmbedUnimplementedPolicyServer()
}

func RegisterPolicyServer(s grpc.ServiceRegistrar, srv PolicyServer) {
	// If the following call pancis, it indicates UnimplementedPolicyServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Policy_ServiceDesc, srv)
}

func _Policy_AvailableBuckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailableBucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).AvailableBuckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_AvailableBuckets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).AvailableBuckets(ctx, req.(*AvailableBucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_AddReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).AddReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_AddReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).AddReplication(ctx, req.(*AddReplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_GetReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).GetReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_GetReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).GetReplication(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_ListReplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReplicationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).ListReplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_ListReplications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).ListReplications(ctx, req.(*ListReplicationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_StreamReplication_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplicationID)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyServer).StreamReplication(m, &grpc.GenericServerStream[ReplicationID, Replication]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Policy_StreamReplicationServer = grpc.ServerStreamingServer[Replication]

func _Policy_PauseReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).PauseReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_PauseReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).PauseReplication(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_ResumeReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).ResumeReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_ResumeReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).ResumeReplication(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_DeleteReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).DeleteReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_DeleteReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).DeleteReplication(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_SwitchWithZeroDowntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchZeroDowntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).SwitchWithZeroDowntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_SwitchWithZeroDowntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).SwitchWithZeroDowntime(ctx, req.(*SwitchZeroDowntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_SwitchWithDowntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchDowntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).SwitchWithDowntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_SwitchWithDowntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).SwitchWithDowntime(ctx, req.(*SwitchDowntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_DeleteSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).DeleteSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_DeleteSwitch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).DeleteSwitch(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_GetSwitchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).GetSwitchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_GetSwitchStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).GetSwitchStatus(ctx, req.(*ReplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_CompareBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).CompareBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_CompareBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).CompareBucket(ctx, req.(*CompareBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_ListRoutings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).ListRoutings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_ListRoutings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).ListRoutings(ctx, req.(*RoutingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_AddRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRoutingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).AddRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_AddRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).AddRouting(ctx, req.(*AddRoutingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_DeleteRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutingID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).DeleteRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_DeleteRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).DeleteRouting(ctx, req.(*RoutingID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_BlockRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutingID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).BlockRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_BlockRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).BlockRouting(ctx, req.(*RoutingID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_UnblockRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoutingID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).UnblockRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_UnblockRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).UnblockRouting(ctx, req.(*RoutingID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Policy_TestProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServer).TestProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Policy_TestProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServer).TestProxy(ctx, req.(*TestProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Policy_ServiceDesc is the grpc.ServiceDesc for Policy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Policy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chorus.Policy",
	HandlerType: (*PolicyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AvailableBuckets",
			Handler:    _Policy_AvailableBuckets_Handler,
		},
		{
			MethodName: "AddReplication",
			Handler:    _Policy_AddReplication_Handler,
		},
		{
			MethodName: "GetReplication",
			Handler:    _Policy_GetReplication_Handler,
		},
		{
			MethodName: "ListReplications",
			Handler:    _Policy_ListReplications_Handler,
		},
		{
			MethodName: "PauseReplication",
			Handler:    _Policy_PauseReplication_Handler,
		},
		{
			MethodName: "ResumeReplication",
			Handler:    _Policy_ResumeReplication_Handler,
		},
		{
			MethodName: "DeleteReplication",
			Handler:    _Policy_DeleteReplication_Handler,
		},
		{
			MethodName: "SwitchWithZeroDowntime",
			Handler:    _Policy_SwitchWithZeroDowntime_Handler,
		},
		{
			MethodName: "SwitchWithDowntime",
			Handler:    _Policy_SwitchWithDowntime_Handler,
		},
		{
			MethodName: "DeleteSwitch",
			Handler:    _Policy_DeleteSwitch_Handler,
		},
		{
			MethodName: "GetSwitchStatus",
			Handler:    _Policy_GetSwitchStatus_Handler,
		},
		{
			MethodName: "CompareBucket",
			Handler:    _Policy_CompareBucket_Handler,
		},
		{
			MethodName: "ListRoutings",
			Handler:    _Policy_ListRoutings_Handler,
		},
		{
			MethodName: "AddRouting",
			Handler:    _Policy_AddRouting_Handler,
		},
		{
			MethodName: "DeleteRouting",
			Handler:    _Policy_DeleteRouting_Handler,
		},
		{
			MethodName: "BlockRouting",
			Handler:    _Policy_BlockRouting_Handler,
		},
		{
			MethodName: "UnblockRouting",
			Handler:    _Policy_UnblockRouting_Handler,
		},
		{
			MethodName: "TestProxy",
			Handler:    _Policy_TestProxy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamReplication",
			Handler:       _Policy_StreamReplication_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "chorus/policy.proto",
}
